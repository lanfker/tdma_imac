/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2005,2006 INRIA
 * Copyright (c) 2009 MIRKO BANCHI *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
 * Author: Mirko Banchi <mk.banchi@gmail.com>
 */
//#include "max-er-edge-interference-tag.h"
#include "ack-sequence-no-tag.h"
#include <iostream>
#include <vector>
#include <sstream>
#include "ns3/assert.h"
#include "ns3/packet.h"
#include "ns3/simulator.h"
#include "ns3/tag.h"
#include "ns3/log.h"
#include "ns3/node.h"
#include "ns3/double.h"
#include "controller.h"
#include "mac-low.h"
#include "wifi-phy.h"
#include "wifi-mac-trailer.h"
#include "qos-utils.h"
#include "wifi-imac-channel.h"
#include "edca-txop-n.h"
#include "interference-tag.h"
#include "math-helper.h"
#include "wifi-net-device.h"
#include "receiver-address-tag.h"
#include "tx-power-dbm-tag.h"
#include "ns3/mac48-address.h"
#include "wifi-imac-phy.h"
#include "noise-plus-interference-tag.h"
#include <algorithm>
#include <cstdlib>
#include <cmath>
NS_LOG_COMPONENT_DEFINE ("MacLow");

#undef NS_LOG_APPEND_CONTEXT
#define NS_LOG_APPEND_CONTEXT std::clog << "[mac=" << m_self << "] "


namespace ns3 {


TypeId
SnrTag::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::SnrTag")
    .SetParent<Tag> ()
    .AddConstructor<SnrTag> ()
    .AddAttribute ("Snr", "The snr of the last packet received",
                   DoubleValue (0.0),
                   MakeDoubleAccessor (&SnrTag::Get),
                   MakeDoubleChecker<double> ())
  ;
  return tid;
}
TypeId
SnrTag::GetInstanceTypeId (void) const
{
  return GetTypeId ();
}

uint32_t
SnrTag::GetSerializedSize (void) const
{
  return sizeof (double);
}
void
SnrTag::Serialize (TagBuffer i) const
{
  i.WriteDouble (m_snr);
}
void
SnrTag::Deserialize (TagBuffer i)
{
  m_snr = i.ReadDouble ();
}
void
SnrTag::Print (std::ostream &os) const
{
  os << "Snr=" << m_snr;
}
void
SnrTag::Set (double snr)
{
  m_snr = snr;
}
double
SnrTag::Get (void) const
{
  return m_snr;
}


MacLowTransmissionListener::MacLowTransmissionListener ()
{
}
MacLowTransmissionListener::~MacLowTransmissionListener ()
{
}
void
MacLowTransmissionListener::GotBlockAck (const CtrlBAckResponseHeader *blockAck,
                                         Mac48Address source)
{
}
void
MacLowTransmissionListener::MissedBlockAck (void)
{
}
MacLowDcfListener::MacLowDcfListener ()
{
}
MacLowDcfListener::~MacLowDcfListener ()
{
}

MacLowBlockAckEventListener::MacLowBlockAckEventListener ()
{
}
MacLowBlockAckEventListener::~MacLowBlockAckEventListener ()
{
}

MacLowTransmissionParameters::MacLowTransmissionParameters ()
  : m_nextSize (0),
    m_waitAck (ACK_NONE),
    m_sendRts (false),
    m_overrideDurationId (Seconds (0))
{
}
void
MacLowTransmissionParameters::EnableNextData (uint32_t size)
{
  m_nextSize = size;
}
void
MacLowTransmissionParameters::DisableNextData (void)
{
  m_nextSize = 0;
}
void
MacLowTransmissionParameters::EnableOverrideDurationId (Time durationId)
{
  m_overrideDurationId = durationId;
}
void
MacLowTransmissionParameters::DisableOverrideDurationId (void)
{
  m_overrideDurationId = Seconds (0);
}
void
MacLowTransmissionParameters::EnableSuperFastAck (void)
{
  m_waitAck = ACK_SUPER_FAST;
}
void
MacLowTransmissionParameters::EnableBasicBlockAck (void)
{
  m_waitAck = BLOCK_ACK_BASIC;
}
void
MacLowTransmissionParameters::EnableCompressedBlockAck (void)
{
  m_waitAck = BLOCK_ACK_COMPRESSED;
}
void
MacLowTransmissionParameters::EnableMultiTidBlockAck (void)
{
  m_waitAck = BLOCK_ACK_MULTI_TID;
}
void
MacLowTransmissionParameters::EnableFastAck (void)
{
  m_waitAck = ACK_FAST;
}
void
MacLowTransmissionParameters::EnableAck (void)
{
  m_waitAck = ACK_NORMAL;
}
void
MacLowTransmissionParameters::DisableAck (void)
{
  m_waitAck = ACK_NONE;
}
void
MacLowTransmissionParameters::EnableRts (void)
{
  m_sendRts = true;
}
void
MacLowTransmissionParameters::DisableRts (void)
{
  m_sendRts = false;
}
bool
MacLowTransmissionParameters::MustWaitAck (void) const
{
  return (m_waitAck != ACK_NONE);
}
bool
MacLowTransmissionParameters::MustWaitNormalAck (void) const
{
  return (m_waitAck == ACK_NORMAL);
}
bool
MacLowTransmissionParameters::MustWaitFastAck (void) const
{
  return (m_waitAck == ACK_FAST);
}
bool
MacLowTransmissionParameters::MustWaitSuperFastAck (void) const
{
  return (m_waitAck == ACK_SUPER_FAST);
}
bool
MacLowTransmissionParameters::MustWaitBasicBlockAck (void) const
{
  return (m_waitAck == BLOCK_ACK_BASIC) ? true : false;
}
bool
MacLowTransmissionParameters::MustWaitCompressedBlockAck (void) const
{
  return (m_waitAck == BLOCK_ACK_COMPRESSED) ? true : false;
}
bool
MacLowTransmissionParameters::MustWaitMultiTidBlockAck (void) const
{
  return (m_waitAck == BLOCK_ACK_MULTI_TID) ? true : false;
}
bool
MacLowTransmissionParameters::MustSendRts (void) const
{
  return m_sendRts;
}
bool
MacLowTransmissionParameters::HasDurationId (void) const
{
  return (m_overrideDurationId != Seconds (0));
}
Time
MacLowTransmissionParameters::GetDurationId (void) const
{
  NS_ASSERT (m_overrideDurationId != Seconds (0));
  return m_overrideDurationId;
}
bool
MacLowTransmissionParameters::HasNextPacket (void) const
{
  return (m_nextSize != 0);
}
uint32_t
MacLowTransmissionParameters::GetNextPacketSize (void) const
{
  NS_ASSERT (HasNextPacket ());
  return m_nextSize;
}

std::ostream &operator << (std::ostream &os, const MacLowTransmissionParameters &params)
{
  os << "["
  << "send rts=" << params.m_sendRts << ", "
  << "next size=" << params.m_nextSize << ", "
  << "dur=" << params.m_overrideDurationId << ", "
  << "ack=";
  switch (params.m_waitAck)
    {
    case MacLowTransmissionParameters::ACK_NONE:
      os << "none";
      break;
    case MacLowTransmissionParameters::ACK_NORMAL:
      os << "normal";
      break;
    case MacLowTransmissionParameters::ACK_FAST:
      os << "fast";
      break;
    case MacLowTransmissionParameters::ACK_SUPER_FAST:
      os << "super-fast";
      break;
    case MacLowTransmissionParameters::BLOCK_ACK_BASIC:
      os << "basic-block-ack";
      break;
    case MacLowTransmissionParameters::BLOCK_ACK_COMPRESSED:
      os << "compressed-block-ack";
      break;
    case MacLowTransmissionParameters::BLOCK_ACK_MULTI_TID:
      os << "multi-tid-block-ack";
      break;
    }
  os << "]";
  return os;
}


/***************************************************************
 *         Listener for PHY events. Forwards to MacLow
 ***************************************************************/


class PhyMacLowListener : public ns3::WifiPhyListener
{
public:
  PhyMacLowListener (ns3::MacLow *macLow)
    : m_macLow (macLow)
  {
  }
  virtual ~PhyMacLowListener ()
  {
  }
  virtual void NotifyRxStart (Time duration)
  {
  }
  virtual void NotifyRxEndOk (void)
  {
  }
  virtual void NotifyRxEndError (void)
  {
  }
  virtual void NotifyTxStart (Time duration)
  {
  }
  virtual void NotifyMaybeCcaBusyStart (Time duration)
  {
  }
  virtual void NotifySwitchingStart (Time duration)
  {
    m_macLow->NotifySwitchingStartNow (duration);
  }
private:
  ns3::MacLow *m_macLow;
};


MacLow::MacLow ()
  : m_normalAckTimeoutEvent (),
    m_fastAckTimeoutEvent (),
    m_superFastAckTimeoutEvent (),
    m_fastAckFailedTimeoutEvent (),
    m_blockAckTimeoutEvent (),
    m_ctsTimeoutEvent (),
    m_sendCtsEvent (),
    m_sendAckEvent (),
    m_sendDataEvent (),
    m_waitSifsEvent (),
    m_currentPacket (0),
    m_listener (0)
{
  NS_LOG_FUNCTION (this);
  m_lastNavDuration = Seconds (0);
  m_lastNavStart = Seconds (0);
  m_ctsBackoffMaxTrials = 4;
  m_promisc = false;  
  m_desiredDataPdr = 0.9;
  m_ackPdr = 0.9;
  m_estimatorWindow = 20;
  m_ewmaCoefficient = 0.8;
  m_sequenceVectorCapacity = 100;
  m_navDuration = 450;
  m_nodesCountUpperBound = Simulator::NodesCountUpperBound;
  m_timeslot = MilliSeconds (8);
  Simulator::Schedule (Simulator::LearningTimeDuration, &MacLow::CalcPriority, this);
  m_nodeActive = false;
  m_controlPacketPayload.clear ();
  m_currentTimeslot = 0;
  m_dataReceiverAddr = Mac48Address::GetBroadcast ();
  m_initialErEdgeInterferenceW = 1.0965e-12;
  m_controlSignalRetryTimes = m_retryTimes; 
  m_retryTimes = 3;
}

MacLow::~MacLow ()
{
  NS_LOG_FUNCTION (this);
}

void
MacLow::SetupPhyMacLowListener (Ptr<WifiPhy> phy)
{
  m_phyMacLowListener = new PhyMacLowListener (this);
  phy->RegisterListener (m_phyMacLowListener);
}


void
MacLow::DoDispose (void)
{
  NS_LOG_FUNCTION (this);
  m_normalAckTimeoutEvent.Cancel ();
  m_fastAckTimeoutEvent.Cancel ();
  m_superFastAckTimeoutEvent.Cancel ();
  m_fastAckFailedTimeoutEvent.Cancel ();
  m_blockAckTimeoutEvent.Cancel ();
  m_ctsTimeoutEvent.Cancel ();
  m_sendCtsEvent.Cancel ();
  m_sendAckEvent.Cancel ();
  m_sendDataEvent.Cancel ();
  m_waitSifsEvent.Cancel ();
  m_phy = 0;
  m_stationManager = 0;
  delete m_phyMacLowListener;
  m_phyMacLowListener = 0;
}

void
MacLow::CancelAllEvents (void)
{
  NS_LOG_FUNCTION (this);
  bool oneRunning = false;
  if (m_normalAckTimeoutEvent.IsRunning ())
    {
      m_normalAckTimeoutEvent.Cancel ();
      oneRunning = true;
    }
  if (m_fastAckTimeoutEvent.IsRunning ())
    {
      m_fastAckTimeoutEvent.Cancel ();
      oneRunning = true;
    }
  if (m_superFastAckTimeoutEvent.IsRunning ())
    {
      m_superFastAckTimeoutEvent.Cancel ();
      oneRunning = true;
    }
  if (m_fastAckFailedTimeoutEvent.IsRunning ())
    {
      m_fastAckFailedTimeoutEvent.Cancel ();
      oneRunning = true;
    }
  if (m_blockAckTimeoutEvent.IsRunning ())
    {
      m_blockAckTimeoutEvent.Cancel ();
      oneRunning = true;
    }
  if (m_ctsTimeoutEvent.IsRunning ())
    {
      m_ctsTimeoutEvent.Cancel ();
      oneRunning = true;
    }
  if (m_sendCtsEvent.IsRunning ())
    {
      m_sendCtsEvent.Cancel ();
      oneRunning = true;
    }
  if (m_sendAckEvent.IsRunning ())
    {
      m_sendAckEvent.Cancel ();
      oneRunning = true;
    }
  if (m_sendDataEvent.IsRunning ())
    {
      m_sendDataEvent.Cancel ();
      oneRunning = true;
    }
  if (m_waitSifsEvent.IsRunning ())
    {
      m_waitSifsEvent.Cancel ();
      oneRunning = true;
    }
  if (oneRunning && m_listener != 0)
    {
      m_listener->Cancel ();
      m_listener = 0;
    }
}

void
MacLow::SetPhy (Ptr<WifiPhy> phy)
{
  m_phy = phy->GetObject<WifiImacPhy> ();
  m_phy->SetReceiveOkCallback (MakeCallback (&MacLow::ReceiveOk, this));
  m_phy->SetReceiveErrorCallback (MakeCallback (&MacLow::ReceiveError, this));
  m_phy->GetObject<WifiImacPhy> ()->SetNodeActiveStatusCallback (MakeCallback (&MacLow::GetNodeActiveStatus, this));
  if (!m_phy->IsStateSwitching ())   
  {
    m_phy->SetChannelNumber (2); // as by default
  }
  //m_phy->GetObject<WifiImacPhy> ()->ScheduleSwitchChannel (Simulator::LearningTimeDuration - NanoSeconds (4000), 2);// channel 2 as control channel
  SetupPhyMacLowListener (phy);
}
void
MacLow::SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> manager)
{
  m_stationManager = manager;
}

void
MacLow::SetAddress (Mac48Address ad)
{
  m_self = ad;
}
void
MacLow::SetAckTimeout (Time ackTimeout)
{
  m_ackTimeout = ackTimeout;
}
void
MacLow::SetBasicBlockAckTimeout (Time blockAckTimeout)
{
  m_basicBlockAckTimeout = blockAckTimeout;
}
void
MacLow::SetCompressedBlockAckTimeout (Time blockAckTimeout)
{
  m_compressedBlockAckTimeout = blockAckTimeout;
}
void
MacLow::SetCtsTimeout (Time ctsTimeout)
{
  m_ctsTimeout = ctsTimeout;
}
void
MacLow::SetSifs (Time sifs)
{
  m_sifs = sifs;
}
void
MacLow::SetSlotTime (Time slotTime)
{
  m_slotTime = slotTime;
}
void
MacLow::SetPifs (Time pifs)
{
  m_pifs = pifs;
}
void
MacLow::SetBssid (Mac48Address bssid)
{
  m_bssid = bssid;
}
void
MacLow::SetPromisc (void)
{
  m_promisc = true;
}
Mac48Address
MacLow::GetAddress (void) const
{
  return m_self;
}
Time
MacLow::GetAckTimeout (void) const
{
  return m_ackTimeout;
}
Time
MacLow::GetBasicBlockAckTimeout () const
{
  return m_basicBlockAckTimeout;
}
Time
MacLow::GetCompressedBlockAckTimeout () const
{
  return m_compressedBlockAckTimeout;
}
Time
MacLow::GetCtsTimeout (void) const
{
  return m_ctsTimeout;
}
Time
MacLow::GetSifs (void) const
{
  return m_sifs;
}
Time
MacLow::GetSlotTime (void) const
{
  return m_slotTime;
}
Time
MacLow::GetPifs (void) const
{
  return m_pifs;
}
Mac48Address
MacLow::GetBssid (void) const
{
  return m_bssid;
}

void
MacLow::SetRxCallback (Callback<void,Ptr<Packet>,const WifiMacHeader *> callback)
{
  m_rxCallback = callback;
}
void MacLow::SetStartTxCallback (StartTxCallback callback)
{
  m_startTxCallback = callback;
}

void MacLow::SetQueueEmptyCallback (BooleanCallback callback)
{
  m_queueEmptyCallback = callback;
}

void
MacLow::RegisterDcfListener (MacLowDcfListener *listener)
{
  m_dcfListeners.push_back (listener);
}


void
MacLow::StartTransmission (Ptr<const Packet> packet,
                           const WifiMacHeader* hdr,
                           MacLowTransmissionParameters params,
                           MacLowTransmissionListener *listener)
{
  NS_LOG_FUNCTION (this << packet << hdr << params << listener);
  /* m_currentPacket is not NULL because someone started
   * a transmission and was interrupted before one of:
   *   - ctsTimeout
   *   - sendDataAfterCTS
   * expired. This means that one of these timers is still
   * running. They are all cancelled below anyway by the
   * call to CancelAllEvents (because of at least one
   * of these two timer) which will trigger a call to the
   * previous listener's cancel method.
   *
   * This typically happens because the high-priority
   * QapScheduler has taken access to the channel from
   * one of the Edca of the QAP.
   */
  m_currentPacket = packet->Copy ();
  m_currentHdr = *hdr;

  CancelAllEvents ();
  m_listener = listener;
  m_txParams = params;

  /*
   * Here we manually set the transmission parameters to enable rts-cts-ack transmission
   * mechanism for our simulation purpose.
   * Basically, we let the sender send RTS before send data, and let the receiver send ACK after
   * receiving data from transmitters.
   * ----------by Chuan Mar 07, 2012
   */

  if (m_currentHdr.IsData () && !m_currentHdr.GetAddr1().IsGroup ()) // data packet but not broadcast packet
  {
    //m_txParams.EnableRts ();
    m_txParams.EnableAck ();
  }
  //NS_ASSERT (m_phy->IsStateIdle ());

  NS_LOG_DEBUG ("startTx size=" << GetSize (m_currentPacket, &m_currentHdr) <<
                ", to=" << m_currentHdr.GetAddr1 () << ", listener=" << m_listener);

  SendDataPacket ();

  /* When this method completes, we have taken ownership of the medium. */
  NS_ASSERT (m_phy->IsStateTx ());
}

void
MacLow::ReceiveError (Ptr<const Packet> packet, double rxSnr)
{
  NS_LOG_FUNCTION (this << packet << rxSnr);
  NS_LOG_DEBUG ("rx failed ");
  if (m_txParams.MustWaitFastAck ())
    {
      NS_ASSERT (m_fastAckFailedTimeoutEvent.IsExpired ());
      m_fastAckFailedTimeoutEvent = Simulator::Schedule (GetSifs (),
                                                         &MacLow::FastAckFailedTimeout, this);
    }
  return;
}

void
MacLow::NotifySwitchingStartNow (Time duration)
{
  NS_LOG_DEBUG ("switching channel. Cancelling MAC pending events");
  m_stationManager->Reset ();
  CancelAllEvents ();
  if (m_navCounterResetCtsMissed.IsRunning ())
    {
      m_navCounterResetCtsMissed.Cancel ();
    }
  m_lastNavStart = Simulator::Now ();
  m_lastNavDuration = Seconds (0);
  m_currentPacket = 0;
  m_listener = 0;
}

//Look up the link table and find out the link that the current node will act as a sender, compute the priority of the link.
//if the current node succeeded in priority calculation, meaning the link has the largest priority value all over its ER
// return true, else return false;
void MacLow::CalcPriority ()
{
  Time scheduleDelay = MicroSeconds (6700);
  if (Simulator::NodesWillSend.size () != 0 && Simulator::SlotBeginningTime != Simulator::Now ())
  {
    // for a new time slot, clear the data for the previous time slot and update the slot beginning time to identify that
    // we are working on a new slot now;
    Simulator::ClearSendingNodes ();
    Simulator::ClearPreemptedNodes ();
    Simulator::SlotBeginningTime = Simulator::Now (); 
  }

  TdmaLink linkInfo = Simulator::FindLinkBySender (m_self.ToString ()); // get the target link
  // only calculate the nodes that  are not preempted by other nodes
  if ( find (Simulator::PreemptedNodes.begin (), Simulator::PreemptedNodes.end (), m_self.ToString () ) == Simulator::PreemptedNodes.end ())
  { 
    //Please note that: For each node, it only has one data receiver
    // Get the links that are incident with the current node.
    std::vector<TdmaLink> linkRelatedLinks = Simulator::FindRelatedLinks (m_self.ToString ());
    // Get the links that are incident with the sender of the link initiated by the current node and add those links into the vector
    // @linkRelatedLinks. Later, we will decide which link has the maximum priority within the vector @linkRelatedLink
    if (linkInfo.linkId != 0 && linkInfo.receiverAddr != Mac48Address::GetBroadcast ().ToString ())
    {
      std::vector<TdmaLink> receiverRelatedLinks = Simulator::FindRelatedLinks (linkInfo.receiverAddr);
      for (std::vector<TdmaLink>::iterator it = receiverRelatedLinks.begin (); it != receiverRelatedLinks.end (); ++ it)
      {
        if (it->linkId != linkInfo.linkId)
        {
          linkRelatedLinks.push_back (*it);
        }
      }
    }
    // linkRelatedLinks contains all the links that are related to either the sender or the receiver
    if ( linkRelatedLinks.size () != 0)
    {
      TdmaLink maxLink = *(linkRelatedLinks.begin ());
      // this for loop is used to find out the link who has the maximum priority value.
      for (std::vector<TdmaLink>::iterator it = linkRelatedLinks.begin (); it != linkRelatedLinks.end (); ++ it)
      {
        if (DoCalculatePriority (it->linkId) > DoCalculatePriority (maxLink.linkId))
        {
          maxLink = *it;
        }
      }

      // when the link who has the maximum priority value (@maxLink) is found, we test if the @maxLink is related to the current node.
      // The are two situations:
      //  1. Related to the current node.
      //    (1). if the current node is the acting as a sender, and the sender of the @maxLink is @m_self, we calculate if the @maxLink can finally 
      //    have the maximum priority within @maxLink's ER.
      //    (2). if the current node is acting as the receiver, if the receiver of the @maxLink is @m_self, it means, it's quite possible that 
      //    @maxLink will succeed at the sender side of @maxLink
      //  2. Not related to the current node ( that means, @maxLink is related to the receiver of the link initiated by the current node)
      //    (1). if the current node is acting as a sender, ignore it. 
      //    (2). if the current node is acting as a receiver, we cannot ignore it. Since it may be possible that the sender of the current node may 
      //    have already gained the maximum priority value when the sender calculated the priority, we should let the current node try to find the 
      //    link with the maximum priority value within the links that are related to the current node. If the sender of the @maxLink is the current
      //    node, ignore it because we are looking the scenarios that the current node is acting as a receiver. If the receiver of the @maxLink is 
      //    the current node, calculate if the link with the current node as the receiver could succeed in having the maximum priority value. If yes,
      //    we want to let this node in data channel and later receive data, otherwise, keep staying in control channel


      if (maxLink.senderAddr != m_self.ToString () && maxLink.receiverAddr != m_self.ToString ()) // both the sender and the receiver of the 
        // @maxLink are not the current node, that means all the links are related to the current node are failed to have the maximum priority
        // this node does not need to calculate priority any more.  ** This situation is for the node being sender
      {
        // if the current node is a receiver, then ...
        std::vector<TdmaLink> selfRelatedLinks = Simulator::FindRelatedLinks (m_self.ToString () ); 
        if (selfRelatedLinks.size () != 0)
        {
          TdmaLink _maxLink = *(selfRelatedLinks.begin ());
          for (std::vector<TdmaLink>::iterator _it = selfRelatedLinks.begin (); _it != selfRelatedLinks.end (); ++ _it)
          {
            if ( DoCalculatePriority (_it->linkId) > DoCalculatePriority (_maxLink.linkId ))
            {
              _maxLink = *_it;
            }
          }
          if ( _maxLink.receiverAddr == m_self.ToString ())
          {
            bool nodeStatus = false;
            nodeStatus = SenderComputeThePriority (maxLink.senderAddr);
            if (nodeStatus == true ) // as receiver
            {
              m_nodeActive = true; 
              // once the node knows it could be active in the slot, stop computing
              Simulator::Schedule (scheduleDelay, &MacLow::SetNodeActiveFalse, this);
              if (!m_phy->IsStateSwitching ())   
              {
                m_phy->GetObject<WifiImacPhy> ()->SetChannelNumber (1); // switch to data channel;
                m_phy->GetObject<WifiImacPhy> ()->ScheduleSwitchChannel (scheduleDelay, 2); // switch to control channel;
              }
            }
            else if (m_controlInformation.size () != 0 )
            {
              ScheduleControlSignalTransmission ();
            }
          }
        }
        else if (m_controlInformation.size () != 0 )
        {
          ScheduleControlSignalTransmission ();
        }
      }
      else if (maxLink.senderAddr == m_self.ToString () && find (Simulator::PreemptedNodes.begin (), Simulator::PreemptedNodes.end (), maxLink.receiverAddr) == Simulator::PreemptedNodes.end ()) //if the node wants to transmit data, the receiver should not be preempted already.
      {
        bool nodeStatus = false;
        nodeStatus = SenderComputeThePriority (maxLink.senderAddr);
        if ( nodeStatus == true ) // as sender
        {
          m_nodeActive = true; 
          // once the node knows it could be active in the slot, stop computing
          Simulator::Schedule (scheduleDelay, &MacLow::SetNodeActiveFalse, this);

          //node preemption
          LinkEstimatorItem maxLinkErInfo = GetEstimatorTableItemByNeighborAddr (Mac48Address(maxLink.senderAddr.c_str()), Mac48Address(maxLink.receiverAddr.c_str ()));// get ER information (edge interference)
          std::vector<std::string> _nodesInEr = Simulator::ListNodesInEr (maxLink.senderAddr, maxLinkErInfo.LastAckErEdgeInterferenceW, maxLink.receiverAddr, maxLinkErInfo.LastDataErEdgeInterferenceW); // get all the nodes in ER. This vector also contains the sender and receiver of the target link
          for(std::vector<std::string>::iterator sub_it = _nodesInEr.begin (); sub_it != _nodesInEr.end (); ++ sub_it)
          {
            if (*sub_it == maxLink.receiverAddr) //also preempt the sender.
            {
              *sub_it = Mac48Address::GetBroadcast ().ToString ();
            }
          }
          Simulator::AddPreemptedNodes (_nodesInEr);

          if (!m_phy->IsStateSwitching ())   
          {
            m_phy->GetObject<WifiImacPhy> ()->SetChannelNumber (1); // switch to data channel;
            m_phy->GetObject<WifiImacPhy> ()->ScheduleSwitchChannel (scheduleDelay, 2); // switch to control channel;
            if (m_queueEmptyCallback () == true && m_dataReceiverAddr != Mac48Address::GetBroadcast ())
            {
              Simulator::Schedule (MicroSeconds (751),&MacLow::GenerateDataPacketAndSend, this);
            }
            else
            {
              Simulator::Schedule (MicroSeconds (751), &MacLow::m_startTxCallback, this);
            }
          }
        }
        else if (m_controlInformation.size () != 0 )
        {
          ScheduleControlSignalTransmission ();
        }
      }
      else if ( maxLink.receiverAddr == m_self.ToString ())
      {
        bool nodeStatus = false;
        nodeStatus = SenderComputeThePriority (maxLink.senderAddr );
        if (nodeStatus == true ) // as receiver
        {
          m_nodeActive = true; 
          // once the node knows it could be active in the slot, stop computing
          Simulator::Schedule (scheduleDelay, &MacLow::SetNodeActiveFalse, this);
          if (!m_phy->IsStateSwitching ())   
          {
            m_phy->GetObject<WifiImacPhy> ()->SetChannelNumber (1); // switch to data channel;
            m_phy->GetObject<WifiImacPhy> ()->ScheduleSwitchChannel (scheduleDelay, 2); // switch to control channel;
          }
        } // failed to have the maximum priority, try to send control signal
        else if (m_controlInformation.size () != 0 )
        {
          ScheduleControlSignalTransmission ();
        }
      }
    }
  }
  // nodes got preempted by others, try to 2end control signal
  else if (m_controlInformation.size () != 0 )
  {
    ScheduleControlSignalTransmission ();
  }
  
  // No matter the @maxLink is related to the current node or not, we need to schedule the priority calculation event for the
  // next timeslot
  if ( Simulator::Now () <= Simulator::SimulationStopTime )
  {
    Simulator::Schedule (m_timeslot, &MacLow::CalcPriority, this);
  }
  return;

}

bool MacLow::SenderComputeThePriority (std::string addr)
{
  //________________________________________________________________________________________________________________
  //                             Compute all the link in ER
  //________________________________________________________________________________________________________________
  std::vector<LinkPriority> linkPriorities;

  TdmaLink linkInfo = Simulator::FindLinkBySender (addr); // get the target link
  // If there is no valid link initiated by the sender, return
  if ( linkInfo.linkId == 0)
  {
    return false;
  }
  Mac48Address sender = Mac48Address(addr.c_str ());
  Mac48Address receiver = Mac48Address (linkInfo.receiverAddr.c_str ());
  // if the receiver is the broadcast addr, that also means there is no valid link initiated by the sender, return 
  if ( receiver == Mac48Address::GetBroadcast ())
  {
    return false;
  }

  // we set teh data packet receiver address here. Later when we need to generate data packet to send at the mac layer,
  // we need this m_dataReceiverAddr
  if ( addr == m_self.ToString () && m_dataReceiverAddr == Mac48Address::GetBroadcast ())
  {
    m_dataReceiverAddr = receiver;
  }

  LinkEstimatorItem linkEstimatorItem = GetEstimatorTableItemByNeighborAddr (sender, receiver);// get ER information (edge interference)
  std::vector<std::string> nodesInEr = Simulator::ListNodesInEr (sender.ToString (), linkEstimatorItem.LastAckErEdgeInterferenceW, receiver.ToString (), linkEstimatorItem.LastDataErEdgeInterferenceW); // get all the nodes in ER. This vector also contains the sender and receiver of the target link
  // has not calculated the target link itself 
  for (std::vector<std::string>::iterator it = nodesInEr.begin (); it != nodesInEr.end (); ++ it) // for every node in ER.
  {
    std::vector<TdmaLink> relatedLinks = Simulator::FindRelatedLinks (*it); // get its related links
    for (std::vector<TdmaLink>::iterator _it = relatedLinks.begin (); _it != relatedLinks.end (); ++ _it)
    { // for all its related link, check if the link has been previously computed?
      bool calculated = false;
      for (std::vector<LinkPriority>::iterator pri_it = linkPriorities.begin (); pri_it != linkPriorities.end (); ++ pri_it)
      {
        if (_it->linkId == pri_it->linkId )//this link has been calculated
        {
          calculated = true;
          break;
        }
      }
      if ( calculated == false) // if not, calculate the priority
      {
        LinkPriority linkPriority;
        linkPriority.linkId = _it->linkId;
        linkPriority.priority = DoCalculatePriority (_it->linkId);
        linkPriorities.push_back (linkPriority); // save the calculated priority
      }
    }
  }

  
  // ____________________________________________________________________________________________________________________________
  //                      This part is similar to the Bi-directional ER logic
  // ____________________________________________________________________________________________________________________________
  std::vector<TdmaLink> allLinks = Simulator::ListAllLinks ();
  for (std::vector<TdmaLink>::iterator it = allLinks.begin (); it != allLinks.end (); ++ it)
  {
    if (it->linkId == linkInfo.linkId ) // if the current link is the target link, ignore it
    {
      continue;
    }
    bool calculated = false;
    for (std::vector<LinkPriority>::iterator pri_it = linkPriorities.begin (); pri_it != linkPriorities.end (); ++ pri_it)
    {
      if (it->linkId == pri_it->linkId )
      {
        calculated = true;
        break;
      }
    }
    if (calculated == true)//this link has been calculated, ignore it
    {
      continue;
    }
    if (calculated == false )// if the current link has not been calculated yet, 
    {
      //Find nodes in ER
      LinkEstimatorItem _linkEstimatorItem = GetEstimatorTableItemByNeighborAddr (Mac48Address (it->senderAddr.c_str ()) ,Mac48Address (it->receiverAddr.c_str ()));// get ER information (edge interference)
      std::vector<std::string> _nodesInEr = Simulator::ListNodesInEr (it->senderAddr, _linkEstimatorItem.LastAckErEdgeInterferenceW, it->receiverAddr, _linkEstimatorItem.LastDataErEdgeInterferenceW); // get all the nodes in ER. This vector also contains the sender and receiver of the target link

      //if the ER of the un-calculated link contains the target link (no matter the sender or receiver or both)
      if ( find (_nodesInEr.begin (), _nodesInEr.end (), linkInfo.senderAddr)!= _nodesInEr.end () ||
           find (_nodesInEr.begin (), _nodesInEr.end (), linkInfo.receiverAddr) != _nodesInEr.end ()) 
      {
        //calculate the priority
        LinkPriority linkPriority;
        linkPriority.linkId = it->linkId;
        linkPriority.priority = DoCalculatePriority (it->linkId);
        linkPriorities.push_back (linkPriority); // save the calculated priority
      }
    } 
  }
  
  //______________________________________________________________________________________________________________________________
  //                    Check if the target link has the maximum priority
  //______________________________________________________________________________________________________________________________
  
  int64_t targetLinkPriority = DoCalculatePriority (linkInfo.linkId);
  int64_t maximumPriority = 0;
  for (std::vector<LinkPriority>::iterator it = linkPriorities.begin (); it != linkPriorities.end (); ++ it)
  {
    if ( it->priority > maximumPriority && it->linkId != linkInfo.linkId )
    {
      maximumPriority = it->priority;
    }
  }
  if (targetLinkPriority > maximumPriority)
  {
    Simulator::ResigerSendingNode(sender.ToString (), linkEstimatorItem.LastAckErEdgeInterferenceW, receiver.ToString (), linkEstimatorItem.LastDataErEdgeInterferenceW);
    return true;
  }
  return false;
}

bool MacLow::GetNodeActiveStatus () const
{
  return m_nodeActive;
}

void MacLow::SetNodeActiveFalse ()
{
  m_nodeActive = false;
}
/* Calculate link priority according to link.id
 */
int64_t MacLow::DoCalculatePriority (int64_t linkId)
{
  int64_t currentSlot = Simulator::Now ().GetNanoSeconds () - Simulator::LearningTimeDuration.GetNanoSeconds () / m_timeslot.GetNanoSeconds ();
  m_currentTimeslot = currentSlot;
  int64_t base = 10;
  while (true)
  {
    if ( currentSlot / base == 0)
    {
      break;
    }
    base *= 10;
  }
  int64_t seed = linkId * base + currentSlot;
  srand (seed ); // set rand seed;
  int64_t priority = rand () * Simulator::NodesCountUpperBound + linkId; 
  return abs (priority);
}

void
MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiMode txMode, WifiPreamble preamble)
{
  NS_LOG_FUNCTION (this << packet << rxSnr << txMode << preamble);
  /* A packet is received from the PHY.
   * When we have handled this packet,
   * we handle any packet present in the
   * packet queue.
   */
  Ptr<WifiImacPhy> imacPhy = m_phy->GetObject<WifiImacPhy> ();
  Ptr<WifiImacChannel> channel = imacPhy->GetChannel()->GetObject<WifiImacChannel> ();
  WifiMacHeader hdr; 
  packet->RemoveHeader (hdr); 
 
  //_____________________________________________________________________________________________________________________
  //                    WHEN receiving a control message
  //_____________________________________________________________________________________________________________________
  if (Simulator::Now () >= Simulator::LearningTimeDuration && imacPhy->GetChannelNumber () == 2)// after learning process, in control channel
  {
    //std::cout<<" received control signal, size: "<<packet->GetSize ()<< std::endl;
    uint8_t *buffer = new uint8_t[packet->GetSize ()];
    packet->CopyData (buffer, packet->GetSize ());
    std::vector<ControlPacketPayload> payload_vec = ParseControlPacketPayload (buffer );
    for (std::vector<ControlPacketPayload>::iterator _it = payload_vec.begin (); _it != payload_vec.end (); ++ _it)
    {
      UpdateEstimatorTableItem (*_it);
    }
    delete [] buffer;
  }

  //_____________________________________________________________________________________________________________________
  //                       When receiving an ACK
  //_____________________________________________________________________________________________________________________
  if (hdr.IsAck ()
           && hdr.GetAddr1 () == m_self
           && m_txParams.MustWaitAck () && imacPhy->GetChannelNumber () == 1) // ack received from the data channel
    {
      NS_LOG_DEBUG ("receive ack from=" << m_currentHdr.GetAddr1 ());

      // report ACK been received and update received ack seq number
      ReceiverAddressTag receiverAddress;
      // ack, for me, after learning process, in data channel
      if (packet->FindFirstMatchingByteTag ( receiverAddress) && Simulator::Now () >= Simulator::LearningTimeDuration)
      {
        Mac48Address ackSenderAddress = receiverAddress.Get ();
        std::cout<<"4: "<<Simulator::Now ()<<" ack from " << ackSenderAddress << " to "<<m_self <<" is received" <<std::endl;
        AckSequenceNoTag ackSequenceNoTag; 
        if (packet->FindFirstMatchingByteTag (ackSequenceNoTag) )
        {
          //for ack link, the sender is the receiver of the data link and the receiver is the sender of the data link
          //so m_self as the sender of the data link should be the first parameter
          UpdateReceivedAckPacketNumbers (m_self, ackSenderAddress, ackSequenceNoTag.Get ()); //?
        }
      }
      
     
      SnrTag tag;
      packet->RemovePacketTag (tag);
      m_stationManager->ReportRxOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
                                    rxSnr, txMode);
      m_stationManager->ReportDataOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
                                      rxSnr, txMode, tag.Get ());
      bool gotAck = false;
      if (m_txParams.MustWaitNormalAck ()
          && m_normalAckTimeoutEvent.IsRunning ())
        {
          m_normalAckTimeoutEvent.Cancel ();
          NotifyAckTimeoutResetNow ();
          gotAck = true;
        }
      if (m_txParams.MustWaitFastAck ()
          && m_fastAckTimeoutEvent.IsRunning ())
        {
          m_fastAckTimeoutEvent.Cancel ();
          NotifyAckTimeoutResetNow ();
          gotAck = true;
        }
      if (gotAck)
        {
          m_listener->GotAck (rxSnr, txMode);
        }
      if (m_txParams.HasNextPacket ())
        {
          m_waitSifsEvent = Simulator::Schedule (GetSifs (),
                                                 &MacLow::WaitSifsAfterEndTx, this);
        }
    }
  else if (hdr.IsCtl ())
    {
      NS_LOG_DEBUG ("rx drop " << hdr.GetTypeString ());
    }
  //____________________________________________________________________________________________________________________________________
  //                            WHEN receiving a DATA
  //____________________________________________________________________________________________________________________________________
  else if (hdr.GetAddr1 () == m_self && imacPhy->GetChannelNumber () == 1) // data packet received in the data channel
    {
      // after learning process, data packet and in data channel
      if (Simulator::Now () >= Simulator::LearningTimeDuration && hdr.IsData ()) 
      {
        //for data, Addr2 is the data link sender, and addr1==@m_self is the data link receiver
        LinkEstimatorItem estimatorItem = GetEstimatorTableItemByNeighborAddr (hdr.GetAddr2 (), m_self);
        std::cout<<"2: "<<Simulator::Now () <<" received data packet from: "<< hdr.GetAddr2 ()<<" to: "<<m_self<<" seq: "<< hdr.GetSequenceNumber ()<<" er_edge: "<< estimatorItem.LastDataErEdgeInterferenceW<< std::endl;
        UpdateReceivedDataPacketNumbers (hdr.GetAddr2 (), m_self, hdr.GetSequenceNumber ()); //
      }
      m_stationManager->ReportRxOk (hdr.GetAddr2 (), &hdr,
                                    rxSnr, txMode);
      if (hdr.IsQosData () && StoreMpduIfNeeded (packet, hdr))
        {
          /* From section 9.10.4 in IEEE802.11:
             Upon the receipt of a QoS data frame from the originator for which
             the Block Ack agreement exists, the recipient shall buffer the MSDU
             regardless of the value of the Ack Policy subfield within the
             QoS Control field of the QoS data frame. */
          if (hdr.IsQosAck ())
            {

              AgreementsI it = m_bAckAgreements.find (std::make_pair (hdr.GetAddr2 (), hdr.GetQosTid ()));
              RxCompleteBufferedPacketsWithSmallerSequence (it->second.first.GetStartingSequence (),
                                                            hdr.GetAddr2 (), hdr.GetQosTid ());
              RxCompleteBufferedPacketsUntilFirstLost (hdr.GetAddr2 (), hdr.GetQosTid ());
              NS_ASSERT (m_sendAckEvent.IsExpired ());
              m_sendAckEvent = Simulator::Schedule (GetSifs (),
                                                    &MacLow::SendAckAfterData, this,
                                                    hdr.GetAddr2 (),
                                                    hdr.GetDuration (),
                                                    txMode,
                                                    rxSnr);
            }
          else if (hdr.IsQosBlockAck ())
            {
              AgreementsI it = m_bAckAgreements.find (std::make_pair (hdr.GetAddr2 (), hdr.GetQosTid ()));
              /* See section 11.5.3 in IEEE802.11 for mean of this timer */
              ResetBlockAckInactivityTimerIfNeeded (it->second.first);
            }
          return;
        }
      else if (hdr.IsQosData () && hdr.IsQosBlockAck ())
        {
          /* This happens if a packet with ack policy Block Ack is received and a block ack
             agreement for that packet doesn't exist.

             From section 11.5.3 in IEEE802.11e:
             When a recipient does not have an active Block ack for a TID, but receives
             data MPDUs with the Ack Policy subfield set to Block Ack, it shall discard
             them and shall send a DELBA frame using the normal access
             mechanisms. */
          AcIndex ac = QosUtilsMapTidToAc (hdr.GetQosTid ());
          m_edcaListeners[ac]->BlockAckInactivityTimeout (hdr.GetAddr2 (), hdr.GetQosTid ());
          return;
        }
      else if (hdr.IsQosData () && hdr.IsQosNoAck ())
        {
          NS_LOG_DEBUG ("rx unicast/noAck from=" << hdr.GetAddr2 ());
        }
      else if (hdr.IsData () || hdr.IsMgt ())
        {
          // iMAC, send ack from here
          NS_LOG_DEBUG ("rx unicast/sendAck from=" << hdr.GetAddr2 ());
          NS_ASSERT (m_sendAckEvent.IsExpired ());
          //m_sendAckEvent = Simulator::Schedule (GetSifs (), &MacLow::SendAckAfterData, this, hdr.GetAddr2 (), hdr.GetDuration (), txMode, rxSnr);
          m_sendAckEvent = Simulator::Schedule (NanoSeconds (1), &MacLow::SendAckAfterData, this, hdr.GetAddr2 (), hdr.GetDuration (), txMode, rxSnr);
        }
      goto rxPacket;
    }
  else if (hdr.GetAddr1 ().IsGroup ())
    {
      if (hdr.IsData () || hdr.IsMgt ())
        {
          NS_LOG_DEBUG ("rx group from=" << hdr.GetAddr2 ());
          goto rxPacket;
        }
      else
        {
          // DROP
        }
    }
  else if (m_promisc)
    {
      NS_ASSERT (hdr.GetAddr1 () != m_self);
      if (hdr.IsData ())
        {
          goto rxPacket;
        }
    }
  else
    {
      //NS_LOG_DEBUG_VERBOSE ("rx not-for-me from %d", GetSource (packet));
    }
  return;
rxPacket:
  WifiMacTrailer fcs;
  packet->RemoveTrailer (fcs);
  m_rxCallback (packet, &hdr);
  return;
}

uint32_t
MacLow::GetAckSize (void) const
{
  WifiMacHeader ack;
  ack.SetType (WIFI_MAC_CTL_ACK);
  return ack.GetSize () + 4;
}
uint32_t
MacLow::GetBlockAckSize (enum BlockAckType type) const
{
  WifiMacHeader hdr;
  hdr.SetType (WIFI_MAC_CTL_BACKRESP);
  CtrlBAckResponseHeader blockAck;
  if (type == BASIC_BLOCK_ACK)
    {
      blockAck.SetType (BASIC_BLOCK_ACK);
    }
  else if (type == COMPRESSED_BLOCK_ACK)
    {
      blockAck.SetType (COMPRESSED_BLOCK_ACK);
    }
  else if (type == MULTI_TID_BLOCK_ACK)
    {
      //Not implemented
      NS_ASSERT (false);
    }
  return hdr.GetSize () + blockAck.GetSerializedSize () + 4;
}
uint32_t
MacLow::GetRtsSize (void) const
{
  WifiMacHeader rts;
  rts.SetType (WIFI_MAC_CTL_RTS);
  return rts.GetSize () + 4;
}
Time
MacLow::GetAckDuration (Mac48Address to, WifiMode dataTxMode) const
{
  WifiMode ackMode = GetAckTxModeForData (to, dataTxMode);
  return m_phy->CalculateTxDuration (GetAckSize (), ackMode, WIFI_PREAMBLE_LONG);
}
Time
MacLow::GetBlockAckDuration (Mac48Address to, WifiMode blockAckReqTxMode, enum BlockAckType type) const
{
  /*
   * For immediate BlockAck we should transmit the frame with the same WifiMode
   * as the BlockAckReq.
   *
   * from section 9.6 in IEEE802.11e:
   * The BlockAck control frame shall be sent at the same rate and modulation class as
   * the BlockAckReq frame if it is sent in response to a BlockAckReq frame.
   */
  return m_phy->CalculateTxDuration (GetBlockAckSize (type), blockAckReqTxMode, WIFI_PREAMBLE_LONG);
}
Time
MacLow::GetCtsDuration (Mac48Address to, WifiMode rtsTxMode) const
{
  WifiMode ctsMode = GetCtsTxModeForRts (to, rtsTxMode);
  return m_phy->CalculateTxDuration (GetCtsSize (), ctsMode, WIFI_PREAMBLE_LONG);
}
uint32_t
MacLow::GetCtsSize (void) const
{
  WifiMacHeader cts;
  cts.SetType (WIFI_MAC_CTL_CTS);
  return cts.GetSize () + 4;
}
uint32_t
MacLow::GetSize (Ptr<const Packet> packet, const WifiMacHeader *hdr) const
{
  WifiMacTrailer fcs;
  return packet->GetSize () + hdr->GetSize () + fcs.GetSerializedSize ();
}

WifiMode
MacLow::GetRtsTxMode (Ptr<const Packet> packet, const WifiMacHeader *hdr) const
{
  Mac48Address to = hdr->GetAddr1 ();
  //std::cout<<" GetMaxSsrc (): "<< m_stationManager->GetMaxSsrc () << std::endl;
  return m_stationManager->GetRtsMode (to, hdr, packet);
}
WifiMode
MacLow::GetDataTxMode (Ptr<const Packet> packet, const WifiMacHeader *hdr) const
{
  Mac48Address to = hdr->GetAddr1 ();
  WifiMacTrailer fcs;
  uint32_t size =  packet->GetSize () + hdr->GetSize () + fcs.GetSerializedSize ();
  return m_stationManager->GetDataMode (to, hdr, packet, size);
}

WifiMode
MacLow::GetCtsTxModeForRts (Mac48Address to, WifiMode rtsTxMode) const
{
  return m_stationManager->GetCtsMode (to, rtsTxMode);
}
WifiMode
MacLow::GetAckTxModeForData (Mac48Address to, WifiMode dataTxMode) const
{
  return m_stationManager->GetAckMode (to, dataTxMode);
}


Time
MacLow::CalculateOverallTxTime (Ptr<const Packet> packet,
                                const WifiMacHeader* hdr,
                                const MacLowTransmissionParameters& params) const
{
  Time txTime = Seconds (0);
  WifiMode rtsMode = GetRtsTxMode (packet, hdr);
  WifiMode dataMode = GetDataTxMode (packet, hdr);
  if (params.MustSendRts ())
    {
      txTime += m_phy->CalculateTxDuration (GetRtsSize (), rtsMode, WIFI_PREAMBLE_LONG);
      txTime += GetCtsDuration (hdr->GetAddr1 (), rtsMode);
      txTime += Time (GetSifs () * 2);
    }
  uint32_t dataSize = GetSize (packet, hdr);
  txTime += m_phy->CalculateTxDuration (dataSize, dataMode, WIFI_PREAMBLE_LONG);
  if (params.MustWaitAck ())
    {
      txTime += GetSifs ();
      txTime += GetAckDuration (hdr->GetAddr1 (), dataMode);
    }
  return txTime;
}

Time
MacLow::CalculateTransmissionTime (Ptr<const Packet> packet,
                                   const WifiMacHeader* hdr,
                                   const MacLowTransmissionParameters& params) const
{
  Time txTime = CalculateOverallTxTime (packet, hdr, params);
  if (params.HasNextPacket ())
    {
      WifiMode dataMode = GetDataTxMode (packet, hdr);
      txTime += GetSifs ();
      txTime += m_phy->CalculateTxDuration (params.GetNextPacketSize (), dataMode, WIFI_PREAMBLE_LONG);
    }
  return txTime;
}

void
MacLow::NotifyNav (const WifiMacHeader &hdr, WifiMode txMode, WifiPreamble preamble)
{
  NS_ASSERT (m_lastNavStart <= Simulator::Now ());
  Time duration = hdr.GetDuration ();

  if (hdr.IsCfpoll ()
      && hdr.GetAddr2 () == m_bssid)
    {
      // see section 9.3.2.2 802.11-1999
      DoNavResetNow (duration);
      return;
    }
  // XXX Note that we should also handle CF_END specially here
  // but we don't for now because we do not generate them.
  else if (hdr.GetAddr1 () != m_self)
    {
      // see section 9.2.5.4 802.11-1999
      bool navUpdated = DoNavStartNow (duration);
      if (hdr.IsRts () && navUpdated)
        {
          /**
           * A STA that used information from an RTS frame as the most recent basis to update its NAV setting
           * is permitted to reset its NAV if no PHY-RXSTART.indication is detected from the PHY during a
           * period with a duration of (2 * aSIFSTime) + (CTS_Time) + (2 * aSlotTime) starting at the
           * PHY-RXEND.indication corresponding to the detection of the RTS frame. The “CTS_Time” shall
           * be calculated using the length of the CTS frame and the data rate at which the RTS frame
           * used for the most recent NAV update was received.
           */
          WifiMacHeader cts;
          cts.SetType (WIFI_MAC_CTL_CTS);
          Time navCounterResetCtsMissedDelay =
            m_phy->CalculateTxDuration (cts.GetSerializedSize (), txMode, preamble) +
            Time (2 * GetSifs ()) + Time (2 * GetSlotTime ());
          m_navCounterResetCtsMissed = Simulator::Schedule (navCounterResetCtsMissedDelay,
                                                            &MacLow::NavCounterResetCtsMissed, this,
                                                            Simulator::Now ());
        }
    }
}

void
MacLow::NavCounterResetCtsMissed (Time rtsEndRxTime)
{
  if (m_phy->GetLastRxStartTime () > rtsEndRxTime)
    {
      DoNavResetNow (Seconds (0.0));
    }
}

void
MacLow::DoNavResetNow (Time duration)
{
  for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
    {
      (*i)->NavReset (duration);
    }
  m_lastNavStart = Simulator::Now ();
  m_lastNavStart = duration;
}
bool
MacLow::DoNavStartNow (Time duration)
{
  for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
    {
      (*i)->NavStart (duration);
    }
  Time newNavEnd = Simulator::Now () + duration;
  Time oldNavEnd = m_lastNavStart + m_lastNavDuration;
  if (newNavEnd > oldNavEnd)
    {
      m_lastNavStart = Simulator::Now ();
      m_lastNavDuration = duration;
      return true;
    }
  return false;
}
void
MacLow::NotifyAckTimeoutStartNow (Time duration)
{
  for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
    {
      (*i)->AckTimeoutStart (duration);
    }
}
void
MacLow::NotifyAckTimeoutResetNow ()
{
  for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
    {
      (*i)->AckTimeoutReset ();
    }
}
void
MacLow::NotifyCtsTimeoutStartNow (Time duration)
{
  for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
    {
      (*i)->CtsTimeoutStart (duration);
    }
}
void
MacLow::NotifyCtsTimeoutResetNow ()
{
  for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
    {
      (*i)->CtsTimeoutReset ();
    }
}

void
MacLow::ForwardDown (Ptr<const Packet> packet, const WifiMacHeader* hdr,
                     WifiMode txMode)
{
  NS_LOG_FUNCTION (this << packet << hdr << txMode);
  NS_LOG_DEBUG ("send " << hdr->GetTypeString () <<
                ", to=" << hdr->GetAddr1 () <<
                ", size=" << packet->GetSize () <<
                ", mode=" << txMode <<
                ", duration=" << hdr->GetDuration () <<
                ", seq=0x" << std::hex << m_currentHdr.GetSequenceControl () << std::dec);
  m_phy->SendPacket (packet, txMode, WIFI_PREAMBLE_LONG, (uint8_t)0); 
}

void
MacLow::CtsTimeout (void)
{
  NS_LOG_FUNCTION (this);
  NS_LOG_DEBUG ("cts timeout");
  // XXX: should check that there was no rx start before now.
  // we should restart a new cts timeout now until the expected
  // end of rx if there was a rx start before now.
  m_stationManager->ReportRtsFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
  m_currentPacket = 0;
  MacLowTransmissionListener *listener = m_listener;
  m_listener = 0;
  listener->MissedCts ();
}
void
MacLow::NormalAckTimeout (void)
{
  NS_LOG_FUNCTION (this);
  NS_LOG_DEBUG ("normal ack timeout");
  // XXX: should check that there was no rx start before now.
  // we should restart a new ack timeout now until the expected
  // end of rx if there was a rx start before now.
  m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
  MacLowTransmissionListener *listener = m_listener;
  m_listener = 0;
  listener->MissedAck ();
}
void
MacLow::FastAckTimeout (void)
{
  NS_LOG_FUNCTION (this);
  m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
  MacLowTransmissionListener *listener = m_listener;
  m_listener = 0;
  if (m_phy->IsStateIdle ())
    {
      NS_LOG_DEBUG ("fast Ack idle missed");
      listener->MissedAck ();
    }
  else
    {
      NS_LOG_DEBUG ("fast Ack ok");
    }
}
void
MacLow::BlockAckTimeout (void)
{
  NS_LOG_FUNCTION (this);
  NS_LOG_DEBUG ("block ack timeout");

  m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
  MacLowTransmissionListener *listener = m_listener;
  m_listener = 0;
  listener->MissedBlockAck ();
}
void
MacLow::SuperFastAckTimeout ()
{
  NS_LOG_FUNCTION (this);
  m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
  MacLowTransmissionListener *listener = m_listener;
  m_listener = 0;
  if (m_phy->IsStateIdle ())
    {
      NS_LOG_DEBUG ("super fast Ack failed");
      listener->MissedAck ();
    }
  else
    {
      NS_LOG_DEBUG ("super fast Ack ok");
      listener->GotAck (0.0, WifiMode ());
    }
}

/*
 * THIS method won't be used in the TDMA version of iMAC
 */
void
MacLow::SendRtsForPacket (void)
{
  NS_LOG_FUNCTION (this);
  /* send an RTS for this packet. */
  WifiMacHeader rts;
  rts.SetType (WIFI_MAC_CTL_RTS);
  rts.SetDsNotFrom ();
  rts.SetDsNotTo ();
  rts.SetNoRetry ();
  rts.SetNoMoreFragments ();
  rts.SetAddr1 (m_currentHdr.GetAddr1 ());
  rts.SetAddr2 (m_self);
  WifiMode rtsTxMode = GetRtsTxMode (m_currentPacket, &m_currentHdr);
  Time duration = Seconds (0);
  if (m_txParams.HasDurationId ())
    {
      duration += m_txParams.GetDurationId ();
    }
  else
    {
      WifiMode dataTxMode = GetDataTxMode (m_currentPacket, &m_currentHdr);
      duration += GetSifs ();
      duration += GetCtsDuration (m_currentHdr.GetAddr1 (), rtsTxMode);
      duration += GetSifs ();
      duration += m_phy->CalculateTxDuration (GetSize (m_currentPacket, &m_currentHdr),
                                              dataTxMode, WIFI_PREAMBLE_LONG);
      duration += GetSifs ();
      duration += GetAckDuration (m_currentHdr.GetAddr1 (), dataTxMode);
    }
  rts.SetDuration (duration);

  Time txDuration = m_phy->CalculateTxDuration (GetRtsSize (), rtsTxMode, WIFI_PREAMBLE_LONG);
  Time timerDelay = txDuration + GetCtsTimeout ();

  NS_ASSERT (m_ctsTimeoutEvent.IsExpired ());
  NotifyCtsTimeoutStartNow (timerDelay);
  m_ctsTimeoutEvent = Simulator::Schedule (timerDelay, &MacLow::CtsTimeout, this);

  Ptr<Packet> packet = Create<Packet> ();
  packet->AddHeader (rts);
  WifiMacTrailer fcs;
  packet->AddTrailer (fcs);

  ForwardDown (packet, &rts, rtsTxMode);
}

void
MacLow::StartDataTxTimers (void)
{
  WifiMode dataTxMode = GetDataTxMode (m_currentPacket, &m_currentHdr);
  Time txDuration = m_phy->CalculateTxDuration (GetSize (m_currentPacket, &m_currentHdr), dataTxMode, WIFI_PREAMBLE_LONG);
  if (m_txParams.MustWaitNormalAck ())
    {
      Time timerDelay = txDuration + GetAckTimeout ();
      NS_ASSERT (m_normalAckTimeoutEvent.IsExpired ());
      NotifyAckTimeoutStartNow (timerDelay);
      m_normalAckTimeoutEvent = Simulator::Schedule (timerDelay, &MacLow::NormalAckTimeout, this);
    }
  else if (m_txParams.MustWaitFastAck ())
    {
      Time timerDelay = txDuration + GetPifs ();
      NS_ASSERT (m_fastAckTimeoutEvent.IsExpired ());
      NotifyAckTimeoutStartNow (timerDelay);
      m_fastAckTimeoutEvent = Simulator::Schedule (timerDelay, &MacLow::FastAckTimeout, this);
    }
  else if (m_txParams.MustWaitSuperFastAck ())
    {
      Time timerDelay = txDuration + GetPifs ();
      NS_ASSERT (m_superFastAckTimeoutEvent.IsExpired ());
      NotifyAckTimeoutStartNow (timerDelay);
      m_superFastAckTimeoutEvent = Simulator::Schedule (timerDelay,
                                                        &MacLow::SuperFastAckTimeout, this);
    }
  else if (m_txParams.MustWaitBasicBlockAck ())
    {
      Time timerDelay = txDuration + GetBasicBlockAckTimeout ();
      NS_ASSERT (m_blockAckTimeoutEvent.IsExpired ());
      m_blockAckTimeoutEvent = Simulator::Schedule (timerDelay, &MacLow::BlockAckTimeout, this);
    }
  else if (m_txParams.MustWaitCompressedBlockAck ())
    {
      Time timerDelay = txDuration + GetCompressedBlockAckTimeout ();
      NS_ASSERT (m_blockAckTimeoutEvent.IsExpired ());
      m_blockAckTimeoutEvent = Simulator::Schedule (timerDelay, &MacLow::BlockAckTimeout, this);
    }
  else if (m_txParams.HasNextPacket ())
    {
      Time delay = txDuration + GetSifs ();
      NS_ASSERT (m_waitSifsEvent.IsExpired ());
      m_waitSifsEvent = Simulator::Schedule (delay, &MacLow::WaitSifsAfterEndTx, this);
    }
  else
    {
      // since we do not expect any timer to be triggered.
      m_listener = 0;
    }
}

void
MacLow::SendDataPacket (void)
{
  NS_LOG_FUNCTION (this);
  /* send this packet directly. No RTS is needed. */
  StartDataTxTimers ();

  WifiMode dataTxMode = GetDataTxMode (m_currentPacket, &m_currentHdr);
  Time duration = Seconds (0.0);
  if (m_txParams.HasDurationId ())
    {
      duration += m_txParams.GetDurationId ();
    }
  else
    {
      if (m_txParams.MustWaitBasicBlockAck ())
        {
          duration += GetSifs ();
          duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), dataTxMode, BASIC_BLOCK_ACK);
        }
      else if (m_txParams.MustWaitCompressedBlockAck ())
        {
          duration += GetSifs ();
          duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), dataTxMode, COMPRESSED_BLOCK_ACK);
        }
      else if (m_txParams.MustWaitAck ())
        {
          duration += GetSifs ();
          duration += GetAckDuration (m_currentHdr.GetAddr1 (), dataTxMode);
        }
      if (m_txParams.HasNextPacket ())
        {
          duration += GetSifs ();
          duration += m_phy->CalculateTxDuration (m_txParams.GetNextPacketSize (),
                                                  dataTxMode, WIFI_PREAMBLE_LONG);
          if (m_txParams.MustWaitAck ())
            {
              duration += GetSifs ();
              duration += GetAckDuration (m_currentHdr.GetAddr1 (), dataTxMode);
            }
        }
    }
  m_currentHdr.SetDuration (duration);
  // parameter: sender, receiver
  if (m_phy->GetChannelNumber () == 1 ) // we only set sequence number when the node is sending data packet
  {
    LinkEstimatorItem estimatorItem = GetEstimatorTableItemByNeighborAddr (m_currentHdr.GetAddr2 (), m_currentHdr.GetAddr1 () );
    m_currentHdr.SetSequenceNumber (estimatorItem.DataSequenceNo);
    estimatorItem.DataSequenceNo ++;
    UpdateEstimatorTableItem (estimatorItem);
  }

  m_currentPacket->AddHeader (m_currentHdr);
  WifiMacTrailer fcs;
  m_currentPacket->AddTrailer (fcs);
  if (Simulator::Now () >= Simulator::LearningTimeDuration && m_phy->GetChannelNumber () == 1) // when node is in data channel, type this message
  {
    std::cout<<"1: " <<Simulator::Now ()<<" sending data packet from: "<<m_self<<" to: "<<m_currentHdr.GetAddr1 () <<" seq: "<<m_currentHdr.GetSequenceNumber () <<"  with outSnr: "<< m_phy->GetObject<WifiImacPhy> ()->GetOutBoundSinrForDest (m_currentHdr.GetAddr1 ()) <<std::endl;
  }
  ForwardDown (m_currentPacket, &m_currentHdr, dataTxMode);
  m_currentPacket = 0;
}

bool
MacLow::IsNavZero (void) const
{
  if (m_lastNavStart + m_lastNavDuration < Simulator::Now ())
    {
      return true;
    }
  else
    {
      return false;
    }
}


/*
 * THIS method won't be used in the version of iMAC
 */
void
MacLow::SendCtsAfterRts (Mac48Address source, Time duration, WifiMode rtsTxMode, double rtsSnr)
{
  NS_LOG_FUNCTION (this << source << duration << rtsTxMode << rtsSnr);
  /* send a CTS when you receive a RTS
   * right after SIFS.
   */
  WifiMode ctsTxMode = GetCtsTxModeForRts (source, rtsTxMode);
  WifiMacHeader cts;
  cts.SetType (WIFI_MAC_CTL_CTS);
  cts.SetDsNotFrom ();
  cts.SetDsNotTo ();
  cts.SetNoMoreFragments ();
  cts.SetNoRetry ();
  cts.SetAddr1 (source);
  duration -= GetCtsDuration (source, rtsTxMode);
  duration -= GetSifs ();
  NS_ASSERT (duration >= MicroSeconds (0));
  cts.SetDuration (duration);

  Ptr<Packet> packet = Create<Packet> ();
  packet->AddHeader (cts);
  WifiMacTrailer fcs;
  packet->AddTrailer (fcs);

  SnrTag tag;
  tag.Set (rtsSnr);
  packet->AddPacketTag (tag);

  ForwardDown (packet, &cts, ctsTxMode);
}

/*
 * THIS method won't be used in the TDMA version of iMAC, since we are going to use @SendDataPacket instead;
 */
void
MacLow::SendDataAfterCts (Mac48Address source, Time duration, WifiMode txMode)
{
  NS_LOG_FUNCTION (this);
  /* send the third step in a
   * RTS/CTS/DATA/ACK hanshake
   */
  NS_ASSERT (m_currentPacket != 0);
  StartDataTxTimers ();

  WifiMode dataTxMode = GetDataTxMode (m_currentPacket, &m_currentHdr);
  Time newDuration = Seconds (0);
  newDuration += GetSifs ();
  newDuration += GetAckDuration (m_currentHdr.GetAddr1 (), dataTxMode);
  Time txDuration = m_phy->CalculateTxDuration (GetSize (m_currentPacket, &m_currentHdr),
                                                dataTxMode, WIFI_PREAMBLE_LONG);
  duration -= txDuration;
  duration -= GetSifs ();

  duration = std::max (duration, newDuration);
  NS_ASSERT (duration >= MicroSeconds (0));
  m_currentHdr.SetDuration (duration);

  m_currentPacket->AddHeader (m_currentHdr);
  WifiMacTrailer fcs;
  m_currentPacket->AddTrailer (fcs);

  ForwardDown (m_currentPacket, &m_currentHdr, dataTxMode);
  m_currentPacket = 0;
}

void
MacLow::WaitSifsAfterEndTx (void)
{
  m_listener->StartNext ();
}

void
MacLow::FastAckFailedTimeout (void)
{
  NS_LOG_FUNCTION (this);
  MacLowTransmissionListener *listener = m_listener;
  m_listener = 0;
  listener->MissedAck ();
  NS_LOG_DEBUG ("fast Ack busy but missed");
}

void
MacLow::SendAckAfterData (Mac48Address source, Time duration, WifiMode dataTxMode, double dataSnr)
{
  NS_LOG_FUNCTION (this);
  /* send an ACK when you receive
   * a packet after SIFS.
   */
  WifiMode ackTxMode = GetAckTxModeForData (source, dataTxMode);
  WifiMacHeader ack;
  ack.SetType (WIFI_MAC_CTL_ACK);
  ack.SetDsNotFrom ();
  ack.SetDsNotTo ();
  ack.SetNoRetry ();
  ack.SetNoMoreFragments ();
  ack.SetAddr1 (source);
  // for ack, @source is the receiver, but for data, @source is the sender, so @source is the first parameter
  LinkEstimatorItem estimatorItem = GetEstimatorTableItemByNeighborAddr (source, m_self);
  AckSequenceNoTag ackSequenceNoTag;
  ackSequenceNoTag.Set (estimatorItem.AckSequenceNo);
  estimatorItem.AckSequenceNo ++;
  UpdateEstimatorTableItem (estimatorItem);
  duration -= GetAckDuration (source, dataTxMode);
  duration -= GetSifs ();
  NS_ASSERT (duration >= MicroSeconds (0));
  ack.SetDuration (duration);

  Ptr<Packet> packet = Create<Packet> ();
  packet->AddHeader (ack);
  WifiMacTrailer fcs;
  packet->AddTrailer (fcs);

  InterferenceTag interferenceTag;
  interferenceTag.Set (estimatorItem.LastDataErEdgeInterferenceW);
  packet->AddByteTag (interferenceTag);

  SnrTag tag;
  tag.Set (dataSnr);
  packet->AddPacketTag (tag);

  ReceiverAddressTag receiverAddress;
  receiverAddress.Set (m_self);
  packet->AddByteTag (receiverAddress);
  packet->AddByteTag (ackSequenceNoTag);

  if (Simulator::Now () >= Simulator::LearningTimeDuration)
  {
    std::cout<<"3: "<<Simulator::Now ()<<" sending ack back to: "<<source<< " from: "<<m_self<<std::endl;
  }
  ForwardDown (packet, &ack, ackTxMode);
}

bool
MacLow::StoreMpduIfNeeded (Ptr<Packet> packet, WifiMacHeader hdr)
{
  AgreementsI it = m_bAckAgreements.find (std::make_pair (hdr.GetAddr2 (), hdr.GetQosTid ()));
  if (it != m_bAckAgreements.end ())
    {
      WifiMacTrailer fcs;
      packet->RemoveTrailer (fcs);
      BufferedPacket bufferedPacket (packet, hdr);

      uint16_t endSequence = ((*it).second.first.GetStartingSequence () + 2047) % 4096;
      uint16_t mappedSeqControl = QosUtilsMapSeqControlToUniqueInteger (hdr.GetSequenceControl (), endSequence);

      BufferedPacketI i = (*it).second.second.begin ();
      for (; i != (*it).second.second.end ()
           && QosUtilsMapSeqControlToUniqueInteger ((*i).second.GetSequenceControl (), endSequence) < mappedSeqControl; i++)
        {
          ;
        }
      (*it).second.second.insert (i, bufferedPacket);

      //Update block ack cache
      BlockAckCachesI j = m_bAckCaches.find (std::make_pair (hdr.GetAddr2 (), hdr.GetQosTid ()));
      NS_ASSERT (j != m_bAckCaches.end ());
      (*j).second.UpdateWithMpdu (&hdr);

      return true;
    }
  return false;
}

void
MacLow::CreateBlockAckAgreement (const MgtAddBaResponseHeader *respHdr, Mac48Address originator,
                                 uint16_t startingSeq)
{
  uint8_t tid = respHdr->GetTid ();
  BlockAckAgreement agreement (originator, tid);
  if (respHdr->IsImmediateBlockAck ())
    {
      agreement.SetImmediateBlockAck ();
    }
  else
    {
      agreement.SetDelayedBlockAck ();
    }
  agreement.SetAmsduSupport (respHdr->IsAmsduSupported ());
  agreement.SetBufferSize (respHdr->GetBufferSize () + 1);
  agreement.SetTimeout (respHdr->GetTimeout ());
  agreement.SetStartingSequence (startingSeq);

  std::list<BufferedPacket> buffer (0);
  AgreementKey key (originator, respHdr->GetTid ());
  AgreementValue value (agreement, buffer);
  m_bAckAgreements.insert (std::make_pair (key, value));

  BlockAckCache cache;
  cache.Init (startingSeq, respHdr->GetBufferSize () + 1);
  m_bAckCaches.insert (std::make_pair (key, cache));

  if (respHdr->GetTimeout () != 0)
    {
      AgreementsI it = m_bAckAgreements.find (std::make_pair (originator, respHdr->GetTid ()));
      Time timeout = MicroSeconds (1024 * agreement.GetTimeout ());

      AcIndex ac = QosUtilsMapTidToAc (agreement.GetTid ());

      it->second.first.m_inactivityEvent = Simulator::Schedule (timeout,
                                                                &MacLowBlockAckEventListener::BlockAckInactivityTimeout,
                                                                m_edcaListeners[ac],
                                                                originator, tid);
    }
}

void
MacLow::DestroyBlockAckAgreement (Mac48Address originator, uint8_t tid)
{
  AgreementsI it = m_bAckAgreements.find (std::make_pair (originator, tid));
  if (it != m_bAckAgreements.end ())
    {
      RxCompleteBufferedPacketsWithSmallerSequence (it->second.first.GetStartingSequence (), originator, tid);
      RxCompleteBufferedPacketsUntilFirstLost (originator, tid);
      m_bAckAgreements.erase (it);

      BlockAckCachesI i = m_bAckCaches.find (std::make_pair (originator, tid));
      NS_ASSERT (i != m_bAckCaches.end ());
      m_bAckCaches.erase (i);
    }
}

void
MacLow::RxCompleteBufferedPacketsWithSmallerSequence (uint16_t seq, Mac48Address originator, uint8_t tid)
{
  AgreementsI it = m_bAckAgreements.find (std::make_pair (originator, tid));
  if (it != m_bAckAgreements.end ())
    {
      uint16_t endSequence = ((*it).second.first.GetStartingSequence () + 2047) % 4096;
      uint16_t mappedStart = QosUtilsMapSeqControlToUniqueInteger (seq, endSequence);
      uint16_t guard = (*it).second.second.begin ()->second.GetSequenceControl () & 0xfff0;
      BufferedPacketI last = (*it).second.second.begin ();

      BufferedPacketI i = (*it).second.second.begin ();
      for (; i != (*it).second.second.end ()
           && QosUtilsMapSeqControlToUniqueInteger ((*i).second.GetSequenceNumber (), endSequence) < mappedStart;)
        {
          if (guard == (*i).second.GetSequenceControl ())
            {
              if (!(*i).second.IsMoreFragments ())
                {
                  while (last != i)
                    {
                      m_rxCallback ((*last).first, &(*last).second);
                      last++;
                    }
                  m_rxCallback ((*last).first, &(*last).second);
                  last++;
                  /* go to next packet */
                  while (i != (*it).second.second.end () && ((guard >> 4) & 0x0fff) == (*i).second.GetSequenceNumber ())
                    {
                      i++;
                    }
                  if (i != (*it).second.second.end ())
                    {
                      guard = (*i).second.GetSequenceControl () & 0xfff0;
                      last = i;
                    }
                }
              else
                {
                  guard++;
                }
            }
          else
            {
              /* go to next packet */
              while (i != (*it).second.second.end () && ((guard >> 4) & 0x0fff) == (*i).second.GetSequenceNumber ())
                {
                  i++;
                }
              if (i != (*it).second.second.end ())
                {
                  guard = (*i).second.GetSequenceControl () & 0xfff0;
                  last = i;
                }
            }
        }
      (*it).second.second.erase ((*it).second.second.begin (), i);
    }
}

void
MacLow::RxCompleteBufferedPacketsUntilFirstLost (Mac48Address originator, uint8_t tid)
{
  AgreementsI it = m_bAckAgreements.find (std::make_pair (originator, tid));
  if (it != m_bAckAgreements.end ())
    {
      uint16_t startingSeqCtrl = ((*it).second.first.GetStartingSequence () << 4) & 0xfff0;
      uint16_t guard = startingSeqCtrl;

      BufferedPacketI lastComplete = (*it).second.second.begin ();
      BufferedPacketI i = (*it).second.second.begin ();
      for (; i != (*it).second.second.end () && guard == (*i).second.GetSequenceControl (); i++)
        {
          if (!(*i).second.IsMoreFragments ())
            {
              while (lastComplete != i)
                {
                  m_rxCallback ((*lastComplete).first, &(*lastComplete).second);
                  lastComplete++;
                }
              m_rxCallback ((*lastComplete).first, &(*lastComplete).second);
              lastComplete++;
            }
          guard = (*i).second.IsMoreFragments () ? (guard + 1) : ((guard + 16) & 0xfff0);
        }
      (*it).second.first.SetStartingSequence ((guard >> 4) & 0x0fff);
      /* All packets already forwarded to WifiMac must be removed from buffer:
      [begin (), lastComplete) */
      (*it).second.second.erase ((*it).second.second.begin (), lastComplete);
    }
}

void
MacLow::SendBlockAckResponse (const CtrlBAckResponseHeader* blockAck, Mac48Address originator, bool immediate,
                              Time duration, WifiMode blockAckReqTxMode)
{
  Ptr<Packet> packet = Create<Packet> ();
  packet->AddHeader (*blockAck);

  WifiMacHeader hdr;
  hdr.SetType (WIFI_MAC_CTL_BACKRESP);
  hdr.SetAddr1 (originator);
  hdr.SetAddr2 (GetAddress ());
  hdr.SetDsNotFrom ();
  hdr.SetDsNotTo ();
  hdr.SetNoRetry ();
  hdr.SetNoMoreFragments ();

  m_currentPacket = packet;
  m_currentHdr = hdr;
  if (immediate)
    {
      m_txParams.DisableAck ();
      duration -= GetSifs ();
      if (blockAck->IsBasic ())
        {
          duration -= GetBlockAckDuration (originator, blockAckReqTxMode, BASIC_BLOCK_ACK);
        }
      else if (blockAck->IsCompressed ())
        {
          duration -= GetBlockAckDuration (originator, blockAckReqTxMode, COMPRESSED_BLOCK_ACK);
        }
      else if (blockAck->IsMultiTid ())
        {
          NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
        }
    }
  else
    {
      m_txParams.EnableAck ();
      duration += GetSifs ();
      duration += GetAckDuration (originator, blockAckReqTxMode);
    }
  m_txParams.DisableNextData ();

  StartDataTxTimers ();

  NS_ASSERT (duration >= MicroSeconds (0));
  hdr.SetDuration (duration);
  //here should be present a control about immediate or delayed block ack
  //for now we assume immediate
  packet->AddHeader (hdr);
  WifiMacTrailer fcs;
  packet->AddTrailer (fcs);
  ForwardDown (packet, &hdr, blockAckReqTxMode);
  m_currentPacket = 0;
}

void
MacLow::SendBlockAckAfterBlockAckRequest (const CtrlBAckRequestHeader reqHdr, Mac48Address originator,
                                          Time duration, WifiMode blockAckReqTxMode)
{
  NS_LOG_FUNCTION (this);
  CtrlBAckResponseHeader blockAck;
  uint8_t tid;
  bool immediate = false;
  if (!reqHdr.IsMultiTid ())
    {
      tid = reqHdr.GetTidInfo ();
      AgreementsI it = m_bAckAgreements.find (std::make_pair (originator, tid));
      if (it != m_bAckAgreements.end ())
        {
          blockAck.SetStartingSequence (reqHdr.GetStartingSequence ());
          blockAck.SetTidInfo (tid);
          immediate = (*it).second.first.IsImmediateBlockAck ();
          if (reqHdr.IsBasic ())
            {
              blockAck.SetType (BASIC_BLOCK_ACK);
            }
          else if (reqHdr.IsCompressed ())
            {
              blockAck.SetType (COMPRESSED_BLOCK_ACK);
            }
          BlockAckCachesI i = m_bAckCaches.find (std::make_pair (originator, tid));
          NS_ASSERT (i != m_bAckCaches.end ());
          (*i).second.FillBlockAckBitmap (&blockAck);

          /* All packets with smaller sequence than starting sequence control must be passed up to Wifimac
           * See 9.10.3 in IEEE8022.11e standard.
           */
          RxCompleteBufferedPacketsWithSmallerSequence (reqHdr.GetStartingSequence (), originator, tid);
          RxCompleteBufferedPacketsUntilFirstLost (originator, tid);
        }
      else
        {
          NS_LOG_DEBUG ("there's not a valid block ack agreement with " << originator);
        }
    } else
    {
      NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
    }

  SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckReqTxMode);
}

void
MacLow::ResetBlockAckInactivityTimerIfNeeded (BlockAckAgreement &agreement)
{
  if (agreement.GetTimeout () != 0)
    {
      NS_ASSERT (agreement.m_inactivityEvent.IsRunning ());
      agreement.m_inactivityEvent.Cancel ();
      Time timeout = MicroSeconds (1024 * agreement.GetTimeout ());

      AcIndex ac = QosUtilsMapTidToAc (agreement.GetTid ());
      //std::map<AcIndex, MacLowTransmissionListener*>::iterator it = m_edcaListeners.find (ac);
      //NS_ASSERT (it != m_edcaListeners.end ());

      agreement.m_inactivityEvent = Simulator::Schedule (timeout,
                                                         &MacLowBlockAckEventListener::BlockAckInactivityTimeout,
                                                         m_edcaListeners[ac],
                                                         agreement.GetPeer (),
                                                         agreement.GetTid ());
    }
}

void
MacLow::RegisterBlockAckListenerForAc (enum AcIndex ac, MacLowBlockAckEventListener *listener)
{
  m_edcaListeners.insert (std::make_pair (ac, listener));
}


/* Although the current node also keeps data for other links
 * , but the current node only updates the sequence number for the links that are related to the current node
 * When as a receiver, update the data packet sequence number and data ER edge interference
 * when as a sender, update the ack packet sequence number and ack ER edge interference
 */
LinkEstimatorItem MacLow::GetEstimatorTableItemByNeighborAddr (Mac48Address sender, Mac48Address receiver )
{
  std::vector<LinkEstimatorItem>::iterator it = m_linkEstimatorTable.begin ();
  for ( ; it != m_linkEstimatorTable.end () ; ++ it)
  {
    if ( it->Sender == sender && it->Receiver == receiver )
    {
      return (*it);
    }
  }
  // if the program reaches here, that means there is no record for the addr. Then, create a new one for this addr
  LinkEstimatorItem newItem;
  newItem.DataSequenceNo = 0;
  newItem.AckSequenceNo = 0;
  newItem.DataPdr = m_desiredDataPdr;
  newItem.AckPdr = m_ackPdr;
  newItem.LastDataSequenceNo = 0;
  newItem.LastAckSequenceNo = 0;
  newItem.Sender = sender;
  newItem.Receiver = receiver;
  newItem.LastDataErEdgeInterferenceW = m_initialErEdgeInterferenceW; //Watt
  newItem.LastAckErEdgeInterferenceW = m_initialErEdgeInterferenceW; // the initial value
  newItem.DataInterferenceW = 0;
  newItem.AckInterferenceW = 0;
  newItem.DataUpdateSeqNo = 0;
  newItem.AckUpdateSeqNo = 0;
  newItem.DataLatestUpdated = true;
  m_linkEstimatorTable.insert ( m_linkEstimatorTable.begin (), newItem);
  return newItem;
}

void MacLow::UpdateEstimatorTableItem (LinkEstimatorItem estimatorItem)
{
  std::vector<LinkEstimatorItem>::iterator it = m_linkEstimatorTable.begin ();
  for ( ; it != m_linkEstimatorTable.end () ; ++ it)
  {
    if ( it->Sender == estimatorItem.Sender && it->Receiver == estimatorItem.Receiver )
    {
      it->DataSequenceNo = estimatorItem.DataSequenceNo;
      it->AckSequenceNo = estimatorItem.AckSequenceNo;
      it->DataPdr = estimatorItem.DataPdr;
      it->AckPdr = estimatorItem.AckPdr;
      it->LastDataErEdgeInterferenceW = estimatorItem.LastDataErEdgeInterferenceW;
      it->LastAckErEdgeInterferenceW = estimatorItem.LastAckErEdgeInterferenceW;
      it->DataInterferenceW = estimatorItem.DataInterferenceW;
      it->AckInterferenceW = estimatorItem.AckInterferenceW;
      it->DataUpdateSeqNo = estimatorItem.DataUpdateSeqNo;
      it->AckUpdateSeqNo = estimatorItem.AckUpdateSeqNo;
      it->DataLatestUpdated = estimatorItem.DataLatestUpdated;
      break;
    }
  }
}

void MacLow::UpdateReceivedDataPacketNumbers (Mac48Address sender, Mac48Address receiver, uint16_t seqNo)
{
  seqNo = seqNo % 4096;
  double estimatedPdr = m_desiredDataPdr;
  double deltaInterferenceDb = 0;
  std::vector<LinkEstimatorItem>::iterator it = m_linkEstimatorTable.begin ();
  for ( ; it != m_linkEstimatorTable.end () ; ++ it)
  {
    if ( it->Sender == sender && it->Receiver == receiver)
    {
      if ( seqNo == it->LastDataSequenceNo)
      {
        break;
      }
      if (find (it->ReceivedDataPacketNumbers.begin (), it->ReceivedDataPacketNumbers.end (), seqNo) == it->ReceivedDataPacketNumbers.end ())
      {
        it->ReceivedDataPacketNumbers.insert (it->ReceivedDataPacketNumbers.begin (), seqNo);
      }
      if (it->ReceivedDataPacketNumbers.size() > m_sequenceVectorCapacity)
      {
        it->ReceivedDataPacketNumbers.pop_back ();
      }
      // estimate link reliability (data pdr)
      double receivedCount = 0.0;
      int difference = 0;
      if ( it->LastDataSequenceNo > seqNo ) // overflow
      {
        difference = seqNo + 4096 - it->LastDataSequenceNo;
      }
      else  // not overflow
      {
        difference = seqNo - it->LastDataSequenceNo;
      }
      if (difference >= m_estimatorWindow)
      {
        receivedCount = it->ReceivedDataPacketNumbers.size ();
        if (receivedCount > 20 )
        {
          std::cout<<" bigger than 20!!!!!"<< " receivedCount: "<< receivedCount <<" lastreceivedDataNumber: "<< it->LastDataSequenceNo << std::endl;
          for (std::vector<uint16_t>::iterator sub_it = it->ReceivedDataPacketNumbers.begin (); sub_it != it->ReceivedDataPacketNumbers.end (); ++ sub_it)
          {
            std::cout<<" seq_number: "<< *sub_it << std::endl;
          }
        }
        it->DataPdr = (1 - m_ewmaCoefficient) * receivedCount / (double)m_estimatorWindow + m_ewmaCoefficient * it->DataPdr;
        std::cout<<"lastdataseqno: "<<it->LastDataSequenceNo<<" ";
        it->LastDataSequenceNo = seqNo;
        it->ReceivedDataPacketNumbers.clear (); // after calculation, remove the already estimated seq numbers
        estimatedPdr = receivedCount / (double) m_estimatorWindow;
        std::cout<<m_self<<" from: "<<sender<<" real segment pdr: "<< receivedCount / (double) m_estimatorWindow << std::endl;
        if (it->DataPdr > 1)
        {
          it->DataPdr = 1;
        }
        /* data estimate the ER region*/
        Ptr<WifiImacPhy> tempPhy = m_phy->GetObject<WifiImacPhy> ();
        Ptr<SignalMap> signalMapItem = tempPhy->GetSignalMapItem (sender);
        it->DataInterferenceW = tempPhy->ComputeInterferenceWhenReceivingData ();
        //double supposedReceivePowerDbm = tempPhy->GetPowerDbmByLevel (0) + tempPhy->GetTxGain () - signalMapItem->outBoundAttenuation;
        tempPhy->ComputeSampledInterferenceW ();
        LinkMetaData linkMetaData = GetLinkMetaDataByLink (m_self, sender);
        //double deltaInterferenceDb = m_pController.GetDeltaInterference(m_desiredDataPdr, it->DataPdr);//in dB
        if (linkMetaData.interferencePreviousDbm != 0 && linkMetaData.interferenceNowDbm != 0)
        {
          deltaInterferenceDb = m_minVarController.GetDeltaInterference (m_desiredDataPdr, it->DataPdr, estimatedPdr );
          std::cout<<m_self<<" from: "<<sender<<" desiredPdr: "<<m_desiredDataPdr << " ewmaCurrentPdr: "<<it->DataPdr << " estimatedCurrentPdr: "<< estimatedPdr <<" deltaInterferenceDb: "<<deltaInterferenceDb<< std::endl;
        }
        if ( linkMetaData.interferencePreviousDbm == 0 || linkMetaData.interferenceNowDbm == 0) // the first time we compute \Delta_I
        {
          linkMetaData.interferencePreviousDbm = linkMetaData.interferenceNowDbm;
          linkMetaData.interferenceNowDbm = 10.0 * log10 (it->DataInterferenceW + tempPhy->GetCurrentNoiseW ()) + 30.0;
          linkMetaData.lastComputedDeltaInterferenceDb = deltaInterferenceDb;
        }
        else
        {

          linkMetaData.interferencePreviousDbm = linkMetaData.interferenceNowDbm;
          linkMetaData.interferenceNowDbm = 10.0 * log10 (it->DataInterferenceW + tempPhy->GetCurrentNoiseW ()) + 30.0;

          double deltaIM = tempPhy->DbmToW (linkMetaData.interferenceNowDbm) - tempPhy->DbmToW (linkMetaData.interferencePreviousDbm);
          double previousDeltaIR = tempPhy->DbmToW (linkMetaData.interferencePreviousDbm + linkMetaData.lastComputedDeltaInterferenceDb) - tempPhy->DbmToW (linkMetaData.interferencePreviousDbm) - linkMetaData.muBWatt;
          double actualDeltaU = deltaIM - previousDeltaIR;


          std::cout<<m_self<<" from: "<< sender<<" previous muBWatt: "<< linkMetaData.muBWatt<< " delta_I_m: "<<deltaIM <<" computed_delta_I(dB): "<<deltaInterferenceDb<<" actual delta_U: "<<actualDeltaU <<" previousDeltaIR: "<<previousDeltaIR;
          //linkMetaData.muBWatt = (1 - m_ewmaCoefficient) * actualDeltaU  + m_ewmaCoefficient * linkMetaData.muBWatt;
          linkMetaData.muBWatt = 0; 
          std::cout<<" new muBWatt: "<< linkMetaData.muBWatt<<std::endl;
          linkMetaData.lastComputedDeltaInterferenceDb = deltaInterferenceDb;
        }
        double expectedInterferenceDbm = 10.0*log10(it->DataInterferenceW + tempPhy->GetCurrentNoiseW ()) + 30.0 + deltaInterferenceDb;
        double expectedInterferenceWatt = pow(10.0, (expectedInterferenceDbm-30)/10.0);
        double deltaInterferenceWatt = expectedInterferenceWatt - it->DataInterferenceW  - tempPhy->GetCurrentNoiseW ()- linkMetaData.muBWatt;
        std::cout<<m_self<<" from: "<<sender<< " expected interference "<< expectedInterferenceWatt<< " newDelta_I_R: "<<deltaInterferenceWatt<<" deltaInterferenceW before muBWatt: "<<expectedInterferenceWatt - it->DataInterferenceW  - tempPhy->GetCurrentNoiseW ()<< " interferenceW: "<<it->DataInterferenceW  + tempPhy->GetCurrentNoiseW ()<<" erSize: "<<tempPhy->GetErSize (it->LastDataErEdgeInterferenceW)<< " concurrentTxNO: "<< tempPhy->GetConcurrentTxNo ()<<" pure_interferenceW: "<<it->DataInterferenceW << std::endl; 
        if (deltaInterferenceDb != 0 && deltaInterferenceWatt == 0)
        {
          std::cout<<" abnormal: delta_interference_db: "<< deltaInterferenceDb <<" expected_interference_watt: "<<expectedInterferenceWatt << " currentInterference: "<<it->DataInterferenceW + tempPhy->GetCurrentNoiseW () <<" delta_interference_watt: "<< (expectedInterferenceWatt - it->DataInterferenceW - tempPhy->GetCurrentNoiseW ()) <<std::endl;
        }
        it->LastDataErEdgeInterferenceW = tempPhy-> GetErEdgeInterference (deltaInterferenceWatt, it->LastDataErEdgeInterferenceW); //Since the data link pdr has changed, we also update the data ER edge interference. /Watt
        it->DataUpdateSeqNo = (it->DataUpdateSeqNo + 1) % 128;
        it->DataLatestUpdated = true;

        ControlPacketPayload payloadItem;
        payloadItem.sender = sender.GetNodeId ();
        payloadItem.receiver = receiver.GetNodeId ();
        payloadItem.isDataLink = true;
        payloadItem.updateSeqNo = it->DataUpdateSeqNo;
        payloadItem.edgeInterferenceW = it->LastDataErEdgeInterferenceW;
        UpdateControlInformation (payloadItem);

        m_controlSignalRetryTimes = m_retryTimes;

        linkMetaData.addr1 = m_self;
        linkMetaData.addr2 = sender;
        linkMetaData.edgeInterferenceW = it->LastDataErEdgeInterferenceW;
        AddOrUpdateErRegion (linkMetaData); //Since here we computed the last data er edge interference for this link (addr --> m_self), we add or update this new er edge interference value to the table (which is actually a vector) @m_linkMetaData and sort the table. If the first item of the table changed, which means the maximum ER region changed, we check if it decreases, if it is, we let the node know this such that when transmit control signal next time, this node can inform the nodes which are no longer within its maximum ER region. By doing so, these nodes can decide whehter the current node can be interfered by them or not. If the current node cannot be interfered by these nodes any more, these nodes do not have to cover the current node if they want to transmit control signal;
        break;
      }
    }
  }
}

void MacLow::UpdateReceivedAckPacketNumbers (Mac48Address sender, Mac48Address receiver, uint16_t seqNo)
{
  double estimatedPdr = m_desiredDataPdr;
  double deltaInterferenceDb = 0;
  std::vector<LinkEstimatorItem>::iterator it = m_linkEstimatorTable.begin ();
  for ( ; it != m_linkEstimatorTable.end () ; ++ it)
  {
    if ( it->Receiver == receiver && it->Sender == sender)
    {
      if (seqNo == it->LastAckSequenceNo )
      {
        break;
      }
      if (find (it->ReceivedAckPacketNumbers.begin (), it->ReceivedAckPacketNumbers.end (), seqNo) == it->ReceivedAckPacketNumbers.end ())
      {
        it->ReceivedAckPacketNumbers.insert (it->ReceivedAckPacketNumbers.begin (), seqNo);
      }
      // estimate link reliability (data pdr)
      double receivedCount = 0.0;
      int difference = 0;   
      if ( it->LastAckSequenceNo > seqNo ) // overflow
      {
        difference = seqNo + 4096 - it->LastAckSequenceNo;
      }
      else  // not overflow
      {
        difference = seqNo - it->LastAckSequenceNo;
      }
      if (difference >= m_estimatorWindow)
      {
        receivedCount = it->ReceivedAckPacketNumbers.size ();
        if (receivedCount > 20 )
        {
          std::cout<<" bigger than 20!!!!!"<< " receivedCount: "<< receivedCount <<" lastreceivedAckNumber: "<< it->LastAckSequenceNo << std::endl;
          for (std::vector<uint16_t>::iterator sub_it = it->ReceivedAckPacketNumbers.begin (); sub_it != it->ReceivedAckPacketNumbers.end (); ++ sub_it)
          {
            std::cout<<" seq_number: "<< *sub_it << std::endl;
          }
        }
        it->AckPdr = (1 - m_ewmaCoefficient) * receivedCount / (double)m_estimatorWindow + m_ewmaCoefficient * it->AckPdr;
        //std::cout<<"lastackseqno: "<<it->LastAckSequenceNo<<" ";
        it->LastAckSequenceNo = seqNo;
        it->ReceivedAckPacketNumbers.clear ();
        estimatedPdr = receivedCount / (double) m_estimatorWindow;
        if (it->AckPdr > 1)
        {
          it->AckPdr = 1;
        }
        /* estimate ack ER region */
        Ptr<WifiImacPhy> tempPhy = m_phy->GetObject<WifiImacPhy> ();
        //Ptr<SignalMap> signalMapItem = tempPhy->GetSignalMapItem (receiver);
        it->AckInterferenceW = tempPhy->ComputeInterferenceWhenReceivingAck ();
        //double supposedReceivePowerDbm = tempPhy->GetPowerDbmByLevel (0) + tempPhy->GetTxGain () - signalMapItem->outBoundAttenuation;
        tempPhy->ComputeSampledInterferenceW ();
        // for ack, the parameter is the ack receiver and ack sender
        LinkMetaData linkMetaData = GetLinkMetaDataByLink (m_self, receiver); 
        //double deltaInterferenceDb = m_pController.GetDeltaInterference(m_ackPdr, it->AckPdr);
        if (linkMetaData.interferencePreviousDbm != 0 && linkMetaData.interferenceNowDbm != 0)
        {
          //deltaInterferenceDb = m_minVarController.GetDeltaInterference (m_ackPdr, it->AckPdr,estimatedPdr, linkMetaData.muBWatt);
          if ( tempPhy->DbmToW ( linkMetaData.interferenceNowDbm) + linkMetaData.muBWatt > 0)
          {
            //muBinDbm = tempPhy->WToDbm (tempPhy->DbmToW ( linkMetaData.interferenceNowDbm) + linkMetaData.muBWatt ) - linkMetaData.interferenceNowDbm;
          }
          deltaInterferenceDb = m_minVarController.GetDeltaInterference (m_ackPdr, it->AckPdr, estimatedPdr );
        }
        if ( linkMetaData.interferencePreviousDbm == 0 || linkMetaData.interferenceNowDbm == 0) // the first time we compute \Delta_I
        {
          linkMetaData.interferencePreviousDbm = linkMetaData.interferenceNowDbm;
          linkMetaData.interferenceNowDbm = 10.0 * log10 (it->AckInterferenceW + tempPhy->GetCurrentNoiseW ()) + 30.0;
          //linkMetaData.muBWatt = (1 - m_ewmaCoefficient) * (-deltaInterferenceDb);
          linkMetaData.lastComputedDeltaInterferenceDb = deltaInterferenceDb;
        }
        else
        {
          linkMetaData.interferencePreviousDbm = linkMetaData.interferenceNowDbm;
          linkMetaData.interferenceNowDbm = 10.0 * log10 (it->AckInterferenceW + tempPhy->GetCurrentNoiseW () ) + 30.0;

          //double deltaIM = tempPhy->DbmToW (linkMetaData.interferenceNowDbm) - tempPhy->DbmToW (linkMetaData.interferencePreviousDbm);
          //double previousDeltaIR = tempPhy->DbmToW (linkMetaData.interferencePreviousDbm + linkMetaData.lastComputedDeltaInterferenceDb) - tempPhy->DbmToW (linkMetaData.interferencePreviousDbm) - linkMetaData.muBWatt;
          //double actualDeltaU = deltaIM - previousDeltaIR;

          //linkMetaData.muBWatt = (1 - m_ewmaCoefficient) * actualDeltaU  + m_ewmaCoefficient * linkMetaData.muBWatt;
          linkMetaData.muBWatt = 0; 
          linkMetaData.lastComputedDeltaInterferenceDb = deltaInterferenceDb;
        }

        double expectedInterferenceDbm = 10.0*log10(it->AckInterferenceW + tempPhy->GetCurrentNoiseW ()) + 30.0 + deltaInterferenceDb;
        double expectedInterferenceWatt = pow(10.0, (expectedInterferenceDbm-30)/10.0);
        double deltaInterferenceWatt = expectedInterferenceWatt - it->AckInterferenceW - tempPhy->GetCurrentNoiseW ()- linkMetaData.muBWatt;
        if (deltaInterferenceDb != 0 && deltaInterferenceWatt == 0)
        {
          std::cout<<" abnormal: delta_interference_db: "<< deltaInterferenceDb <<" expected_interference_watt: "<<expectedInterferenceWatt << " currentInterference: "<<it->AckInterferenceW + tempPhy->GetCurrentNoiseW () <<" delta_interference_watt: "<< (expectedInterferenceWatt - it->AckInterferenceW - tempPhy->GetCurrentNoiseW ()) <<std::endl;
        }
        //std::cout<<" previous ack edge interference: "<<it->LastAckErEdgeInterferenceW;
        it->LastAckErEdgeInterferenceW = tempPhy-> GetErEdgeInterference (deltaInterferenceWatt, it->LastAckErEdgeInterferenceW); //Since the data link pdr has changed, we also update the data ER edge interference
        it->AckUpdateSeqNo = (it->AckUpdateSeqNo + 1) % 128;
        it->DataLatestUpdated = false; // do not need to insert the item in the front of the vector.

        ControlPacketPayload payloadItem;
        payloadItem.sender = sender.GetNodeId ();
        payloadItem.receiver = receiver.GetNodeId ();
        payloadItem.updateSeqNo = it->AckUpdateSeqNo;
        payloadItem.isDataLink = false;
        payloadItem.edgeInterferenceW = it->LastAckErEdgeInterferenceW;
        UpdateControlInformation (payloadItem);

        m_controlSignalRetryTimes = m_retryTimes;

        linkMetaData.addr1 = m_self; //ack receiver
        linkMetaData.addr2 = receiver;  //ack sender
        linkMetaData.edgeInterferenceW = it->LastAckErEdgeInterferenceW;
        AddOrUpdateErRegion (linkMetaData);
        break;
      }
    }
  }
}
/* Add or update ER edge interference for the current node. sort the vector according to the edge interference power
 * in a decreasing fashion. Note that if we want to get the maximum ER region for a specific node, we just have to fetch the very 
 * first item in this vector @m_linkMetaData; 
 * Since the network topology does not change during the simulation and there is no node failure, we suppose the link does not change
 * over time
 */
void MacLow::AddOrUpdateErRegion (LinkMetaData item)
{
  for(std::vector<LinkMetaData>::iterator iter = m_linkMetaData.begin (); iter != m_linkMetaData.end (); ++ iter)
  {
    if ( iter->addr1 == item.addr1 && iter->addr2 == item.addr2)
    {// update the er interference power
      iter->edgeInterferenceW = item.edgeInterferenceW;
      iter->interferenceNowDbm = item.interferenceNowDbm;
      iter->interferencePreviousDbm = item.interferencePreviousDbm;
      iter->lastComputedDeltaInterferenceDb = item.lastComputedDeltaInterferenceDb;
      iter->muBWatt = item.muBWatt;
    }
  }
  m_linkMetaData.push_back (item);
}
/* Get record according to the link. If there is no record for this link, create a new item and return it.
 */
LinkMetaData MacLow::GetLinkMetaDataByLink (Mac48Address receiver, Mac48Address sender) const
{
  for(std::vector<LinkMetaData>::const_iterator iter = m_linkMetaData.begin (); iter != m_linkMetaData.end (); ++ iter)
  {
    if ( iter->addr1 == receiver && iter->addr2 == sender)
    {
      return *iter;
    }
  }
  // if there is no record regarding this link, we create a new record and return;
  LinkMetaData linkMetaData;
  linkMetaData.addr1 = receiver; // address of the sender (no matter the ack sender or data sender)
  linkMetaData.addr2 = sender; // address of the receiver (including ack receiver and data receiver)
  linkMetaData.edgeInterferenceW = 0.0; // the ER edge interference for this transmission from receiver to sender
  linkMetaData.interferenceNowDbm = 0.0;
  linkMetaData.interferencePreviousDbm = 0.0; // the real \DeltaI = m_interferenceNow - m_interferencePrevious;
  linkMetaData.lastComputedDeltaInterferenceDb = 0.0;
  linkMetaData.muBWatt = 0.0; // the average value of the interference outside of the ER
  return linkMetaData;
}


template <typename T>
std::string MacLow::ToString (T const &val)
{
  std::stringstream sstr;
  sstr << val;
  return sstr.str();
}
std::vector<ControlPacketPayload> MacLow::ParseControlPacketPayload (uint8_t* buffer)
{
  std::vector<ControlPacketPayload> items;
  uint8_t size = 11;
  //std::cout<<" printing out received control signal! " << std::endl;
  for (uint8_t i = 0; i < size && buffer [i * 9 ] != '\0'; ++ i)
  {
    uint16_t sender = 0;
    uint16_t receiver = 0;
    float edgeInterferenceW = 0;
    uint8_t *p = (uint8_t *)&edgeInterferenceW;
    ControlPacketPayload item;
    sender = buffer[i * 9 + 1];
    sender <<= 8;
    sender |= buffer[i * 9 + 0];
    item.sender = sender;
    receiver = buffer[i * 9 + 3];
    receiver <<= 8;
    receiver |= buffer[i * 9 + 2];
    item.receiver = receiver;
    item.isDataLink = (buffer[i * 9 + 4] >> 7) == 1 ? true : false;
    item.updateSeqNo = (buffer[i * 9 + 4] & 0x7f);
    for (uint8_t h = 0; h < sizeof (float); ++h, ++p)
    {
      *p = buffer[i * 9 + 5 + h];
    }
    item.edgeInterferenceW = edgeInterferenceW;
    //std::cout<<" sender: "<< item.sender <<" receiver: "<<item.receiver <<" data: "<< item.isDataLink <<" seqno: "<< (uint32_t)item.updateSeqNo <<" edge: "<< item.edgeInterferenceW <<std::endl;
    items.push_back (item);
  }

  return items;
}
void MacLow::UpdateEstimatorTableItem (ControlPacketPayload payload)
{
  LinkEstimatorItem item;
  item.Sender = Mac48Address::GetBroadcast (); 
  for (std::vector<LinkEstimatorItem>::iterator it = m_linkEstimatorTable.begin (); it != m_linkEstimatorTable.end () ; ++ it)
  {
    if ( it->Sender.ToString () == IntToMacAddress (payload.sender) && it->Receiver.ToString () == IntToMacAddress (payload.receiver ))
    {
      if ( payload.isDataLink == true )
      {
        if (it->LastDataErEdgeInterferenceW == payload.edgeInterferenceW )
        {
          return;
        }
        else if (it->LastDataErEdgeInterferenceW != payload.edgeInterferenceW)
        {
          if ((it->DataUpdateSeqNo < payload.updateSeqNo || abs (it->DataUpdateSeqNo - payload.updateSeqNo) > 100 ))
          {
            item.DataSequenceNo = it->DataSequenceNo;
            item.AckSequenceNo = it->AckSequenceNo;
            item.DataPdr = it->DataPdr;
            item.AckPdr = it->AckPdr;
            item.LastDataSequenceNo = it->LastDataSequenceNo;
            item.LastAckSequenceNo = it->LastAckSequenceNo;
            item.Sender = it->Sender;
            item.Receiver = it->Receiver;
            item.LastDataErEdgeInterferenceW = payload.edgeInterferenceW;
            item.LastAckErEdgeInterferenceW = it->LastAckErEdgeInterferenceW;
            item.DataInterferenceW = it->DataInterferenceW;
            item.AckInterferenceW = it->AckInterferenceW;
            item.DataUpdateSeqNo = payload.updateSeqNo;
            item.AckUpdateSeqNo = it->AckUpdateSeqNo;
            item.DataLatestUpdated = true;
            m_linkEstimatorTable.erase (it);
            break;
          }
          else
          {
            return;
          }
        }
      }
      else if (payload.isDataLink == false)
      {
        if (it->LastAckErEdgeInterferenceW == payload.edgeInterferenceW)
        {
          return;
        }
        else if (it->LastDataErEdgeInterferenceW != payload.edgeInterferenceW)
        {
          if ((it->AckUpdateSeqNo < payload.updateSeqNo || abs (it->AckUpdateSeqNo - payload.updateSeqNo) > 100 ))
          {
            item.DataSequenceNo = it->DataSequenceNo;
            item.AckSequenceNo = it->AckSequenceNo;
            item.DataPdr = it->DataPdr;
            item.AckPdr = it->AckPdr;
            item.LastDataSequenceNo = it->LastDataSequenceNo;
            item.LastAckSequenceNo = it->LastAckSequenceNo;
            item.Sender = it->Sender;
            item.Receiver = it->Receiver;
            item.LastDataErEdgeInterferenceW = it->LastDataErEdgeInterferenceW;
            item.LastAckErEdgeInterferenceW = payload.edgeInterferenceW;
            item.DataInterferenceW = it->DataInterferenceW;
            item.AckInterferenceW = it->AckInterferenceW;
            item.DataUpdateSeqNo = it->DataSequenceNo;
            item.AckUpdateSeqNo = payload.updateSeqNo;
            item.DataLatestUpdated = false;
            m_linkEstimatorTable.erase (it);
            break;
          }
          else
          {
            return;
          }
        }
      }
    }
  }
  if (item.Sender != Mac48Address::GetBroadcast ())
  {
    m_linkEstimatorTable.insert (m_linkEstimatorTable.begin (), item);
    return;
  }
  LinkEstimatorItem newItem;
  newItem.DataSequenceNo = 0;
  newItem.AckSequenceNo = 0;
  newItem.DataPdr = m_desiredDataPdr;
  newItem.AckPdr = m_ackPdr;
  newItem.LastDataSequenceNo = 0;
  newItem.LastAckSequenceNo = 0;
  newItem.Sender = Mac48Address ((IntToMacAddress (payload.sender)).c_str ());
  newItem.Receiver = Mac48Address ((IntToMacAddress (payload.receiver)).c_str ());
  newItem.LastDataErEdgeInterferenceW = payload.isDataLink == true ? payload.edgeInterferenceW : m_initialErEdgeInterferenceW; //Watt
  newItem.LastAckErEdgeInterferenceW = payload.isDataLink == false? payload.edgeInterferenceW : m_initialErEdgeInterferenceW; // the initial value
  newItem.DataInterferenceW = 0;
  newItem.AckInterferenceW = 0;
  newItem.DataUpdateSeqNo = 0;
  newItem.AckUpdateSeqNo = 0;
  if (payload.isDataLink)
  {
    newItem.DataLatestUpdated = true;
  }
  else
  {
    newItem.DataLatestUpdated = false;
  }
  m_linkEstimatorTable.insert ( m_linkEstimatorTable.begin (), newItem);
}

/* When the link does not have the maximum link priority, both the sender and the receiver of the link keep staying in 
 * the control channel, and sense the channel, if the channel is idle, broadcast control packet.
 */
void MacLow::TrySendControlPacket ()
{
  if ( m_phy->IsStateCcaBusy () == false && m_phy->IsStateTx () == false && m_phy->IsStateSwitching () == false && m_phy->IsStateRx () == false)
  {
    std::cout<<m_self.GetNodeId ()<<" printing out sending payload: " << std::endl;
    uint8_t *payload;
    uint8_t *ptr = NULL;
    m_setLisenterCallback ();
    m_controlPacketPayload.clear ();
    uint8_t payloadSize = 11 * 9 + 1; // the last 1 is for '\0'
    payload = new uint8_t [payloadSize];
    ptr = payload;
    for ( std::vector<ControlPacketPayload>::iterator it = m_controlInformation.begin (); it != m_controlInformation.end (); ++ it)
    {
      *(ptr++) = (it->sender & 0xff);
      *(ptr++) = ((it->sender >> 8) & 0xff); // sender
      *(ptr++) = (it->receiver & 0xff);
      *(ptr++) = ((it->receiver >> 8) & 0xff); // receiver
      
      if (it->isDataLink == true)
      {
        *(ptr) = 1; // data er
        *(ptr) <<= 7; 
        *(ptr++) |= it->updateSeqNo;// update seq no
      }
      else 
      {
        *(ptr) = 0; // ack er
        *(ptr) <<= 7;
        *(ptr++) |= it->updateSeqNo; // update seq no
      }
      float temp = it->edgeInterferenceW;
      uint8_t* p = (uint8_t *) &temp;
      for (uint8_t h = 0; h < sizeof (float); ++ h)
      {
        *(ptr++) = *(p++); // er edge interference
      }
      p = NULL;
      std::cout<<" sender: "<<it->sender <<" receiver: "<< it->receiver <<" data: "<< it->isDataLink <<" seq: "<< (uint32_t)it->updateSeqNo << " edge: "<< it->edgeInterferenceW <<std::endl;
    }
    for (std::vector<LinkEstimatorItem>::iterator it = m_linkEstimatorTable.begin (); it != m_linkEstimatorTable.end (); ++ it)
    {
      //std::cout<<" ptr - payload: "<< ptr - payload << std::endl;
      if ( ptr - payload > 98)
      {
        break;
      }
      if ( it->Sender != m_self && it->Receiver != m_self)
      {
        uint16_t sender = it->Sender.GetNodeId ();
        uint16_t receiver = it->Receiver.GetNodeId ();
        *(ptr++) = (sender & 0xff);
        *(ptr++) = ((sender >> 8) & 0xff); // sender
        *(ptr++) = (receiver & 0xff);
        *(ptr++) = ((receiver >> 8) & 0xff); // receiver
        if (it->DataLatestUpdated == true )
        {
          *(ptr) = 1;
          *(ptr) <<= 7;
          *(ptr++) |= it->DataUpdateSeqNo;

          float temp = it->LastDataErEdgeInterferenceW;
          uint8_t* p = (uint8_t *) &temp;
          for (uint8_t h = 0; h < sizeof (float); ++ h)
          {
            *(ptr++) = *(p++); // er edge interference
          }
          p = NULL;
        }
        else if (it->DataLatestUpdated == false)
        {
          *(ptr) = 0;
          *(ptr) <<= 7;
          *(ptr++) |= it->AckUpdateSeqNo;
          float temp = it->LastAckErEdgeInterferenceW;
          uint8_t* p = (uint8_t *) &temp;
          for (uint8_t h = 0; h < sizeof (float); ++ h)
          {
            *(ptr++) = *(p++); // er edge interference
          }
          p = NULL;
        }
        std::cout<<" sender: "<< sender <<" receiver: "<< receiver <<" data: "<< it->DataLatestUpdated <<" seq: "<< (it->DataLatestUpdated == true ? (uint32_t)it->DataUpdateSeqNo : (uint32_t)it->AckUpdateSeqNo) <<" edge: "<< (it->DataLatestUpdated == true ? it->LastDataErEdgeInterferenceW : it->LastAckErEdgeInterferenceW) << std::endl;
      }
    }
    
    *ptr = '\0';
    ptr = NULL;
    Ptr<Packet> pkt = Create<Packet> (payload, payloadSize);
    delete [] payload;
    WifiMacHeader hdr;
    hdr.SetAddr2 (m_self);
    hdr.SetDsNotTo ();
    hdr.SetDsNotFrom ();
    hdr.SetFragmentNumber (0);
    hdr.SetNoRetry ();
    hdr.SetAddr1 (m_self);
    hdr.SetTypeData ();
    MacLowTransmissionParameters params;
    params.DisableAck ();
    params.DisableRts ();
    params.DisableOverrideDurationId ();
    params.DisableNextData ();
    m_currentPacket = pkt;
    m_currentHdr = hdr;
    m_setPacketCallback (hdr, pkt);
    m_txParams = params;
    SendDataPacket ();
    if ( m_controlSignalRetryTimes != 0)
    {
      m_controlSignalRetryTimes -- ;
    }
  }
  return;
}
void MacLow::GenerateDataPacketAndSend ()
{  
  m_setLisenterCallback ();
  Ptr<Packet> pkt = Create<Packet> (90); // packet size get from scratch/imac.cc
  WifiMacHeader hdr;
  hdr.SetAddr2 (m_self);
  NS_ASSERT (!m_dataReceiverAddr.IsGroup ());
  hdr.SetAddr1 (m_dataReceiverAddr);
  hdr.SetDsNotTo ();
  hdr.SetDsNotFrom ();
  hdr.SetFragmentNumber (0);
  hdr.SetNoRetry ();
 
  hdr.SetTypeData ();
  MacLowTransmissionParameters params;
  params.EnableAck ();
  params.DisableRts ();
  params.DisableOverrideDurationId ();
  params.DisableNextData ();
  m_currentPacket = pkt;
  m_currentHdr = hdr;
  m_setPacketCallback (hdr, pkt);
  m_txParams = params;
  SendDataPacket ();
}
void MacLow::SetMacLowTransmissionListener (MacLowTransmissionListener *listener )
{
  m_listener = listener;
}
void MacLow::SetListenerCallback (VoidCallback callback)
{
  m_setLisenterCallback = callback;
}
void MacLow::SetDcaTxopPacketCallback (SetPacketCallback callback)
{
  m_setPacketCallback = callback;
}

void MacLow::ScheduleControlSignalTransmission ()
{
  int64_t seed = m_currentTimeslot * Simulator::NodesCountUpperBound + m_self.GetNodeId ();
  srand (seed ); // set rand seed;
  if (m_controlSignalRetryTimes != 0)
  {
    int backoffTime = rand () % NanoSeconds (1500000).GetNanoSeconds (); 
    Simulator::Schedule (NanoSeconds (abs (backoffTime)), &MacLow::TrySendControlPacket, this);
  }
  else if (m_controlSignalRetryTimes == 0)
  {
    int backoffTime = rand () % NanoSeconds (1500000).GetNanoSeconds () + 1500000; 
    Simulator::Schedule (NanoSeconds (abs (backoffTime)), &MacLow::TrySendControlPacket, this);
  }
}

void MacLow::UpdateControlInformation (ControlPacketPayload payload)
{
  // remove the old item, and insert the lastest item in the front of the vector @m_controlInformation
  for (std::vector<ControlPacketPayload>::iterator it = m_controlInformation.begin (); it != m_controlInformation.end (); ++ it)
  {
    if (payload.sender == it->sender && payload.receiver == it->receiver && payload.isDataLink == it->isDataLink)
    {
      it->edgeInterferenceW = payload.edgeInterferenceW;
      it->updateSeqNo = payload.updateSeqNo;
      return;
    }
  }
  m_controlInformation.insert (m_controlInformation.begin (), payload);
}
std::string MacLow::IntToMacAddress (uint16_t nodeId)
{
  string str = "00:00:00:00:00:00";
  if ( nodeId < 16)
  {
    if (nodeId < 10)
    {
      str[16] = '0'+nodeId;
    }
    else if (nodeId >=10 && nodeId <16)
    {
      str[16] = 'a'+nodeId - 10;
    }
    return str;
  }
  else if (nodeId < 16*16)
  {
    uint16_t second = nodeId / 16;
    if (second < 10)
    {
      str[15] = '0'+second;
    }
    else if ( second >= 10 && second <16)
    {
      str[15] = 'a'+second - 10;
    }
    uint16_t first = nodeId % 16;
    if (first < 10)
    {
      str[16] = '0'+first;
    }
    else if (first >= 10 && second <16)
    {
      str[16] = 'a'+first - 10;
    }
    return str;
  }
  else if (nodeId < 16*16*16)
  {
    uint16_t third = nodeId / (16*16);
    if (third < 10)
    {
      str[13] = '0'+ third;
    }
    else if ( third >= 10 && third <16)
    {
      str[13] = 'a'+ third - 10;
    }
    uint16_t second = (nodeId % (16*16))/ 16;
    if (second < 10)
    {
      str[15] = '0'+ second;
    }
    else if ( second >= 10 && second <16)
    {
      str[15] = 'a'+ second - 10;
    }
    uint16_t first = nodeId % 16;
    if (first < 10)
    {
      str[16] = '0'+ first;
    }
    else if (first >= 10 && second <16)
    {
      str[16] = 'a'+ first - 10;
    }
    return str;
  }
  return str;
}
} // namespace ns3
